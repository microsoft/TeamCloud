# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from typing import Any, Callable, Dict, Generic, List, Optional, TypeVar, Union
import warnings

from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse, HttpRequest

from ... import models as _models

T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class TeamCloudClientOperationsMixin:

    async def get_adapters(
        self,
        **kwargs: Any
    ) -> Optional[Union["_models.AdapterInformationListDataResult", "_models.ErrorResult"]]:
        """Gets all Adapters.

        Gets all Adapters.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: AdapterInformationListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.AdapterInformationListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.AdapterInformationListDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_adapters.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('AdapterInformationListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_adapters.metadata = {'url': '/adapters'}  # type: ignore

    async def get_components(
        self,
        organization_id: str,
        project_id: str,
        deleted: Optional[bool] = False,
        **kwargs: Any
    ) -> Optional[Union["_models.ComponentListDataResult", "_models.ErrorResult"]]:
        """Gets all Components for a Project.

        Gets all Components for a Project.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param deleted:
        :type deleted: bool
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ComponentListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ComponentListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ComponentListDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_components.metadata['url']  # type: ignore
        path_format_arguments = {
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if deleted is not None:
            query_parameters['deleted'] = self._serialize.query("deleted", deleted, 'bool')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ComponentListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_components.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/components'}  # type: ignore

    async def create_component(
        self,
        organization_id: str,
        project_id: str,
        body: Optional["_models.ComponentDefinition"] = None,
        **kwargs: Any
    ) -> Optional[Union["_models.ComponentDataResult", "_models.StatusResult", "_models.ErrorResult"]]:
        """Creates a new Project Component.

        Creates a new Project Component.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param body:
        :type body: ~teamcloud.models.ComponentDefinition
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ComponentDataResult or StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ComponentDataResult or ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ComponentDataResult", "_models.StatusResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_component.metadata['url']  # type: ignore
        path_format_arguments = {
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'ComponentDefinition')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201, 202, 400, 401, 403, 404, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 201:
            deserialized = self._deserialize('ComponentDataResult', pipeline_response)

        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_component.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/components'}  # type: ignore

    async def get_component(
        self,
        component_id: str,
        organization_id: str,
        project_id: str,
        **kwargs: Any
    ) -> Optional[Union["_models.ComponentDataResult", "_models.ErrorResult"]]:
        """Gets a Project Component.

        Gets a Project Component.

        :param component_id:
        :type component_id: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ComponentDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ComponentDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ComponentDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_component.metadata['url']  # type: ignore
        path_format_arguments = {
            'componentId': self._serialize.url("component_id", component_id, 'str'),
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ComponentDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_component.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/components/{componentId}'}  # type: ignore

    async def delete_component(
        self,
        component_id: str,
        organization_id: str,
        project_id: str,
        **kwargs: Any
    ) -> Optional[Union["_models.StatusResult", "_models.ComponentDataResult", "_models.ErrorResult"]]:
        """Deletes an existing Project Component.

        Deletes an existing Project Component.

        :param component_id:
        :type component_id: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ComponentDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ComponentDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.StatusResult", "_models.ComponentDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_component.metadata['url']  # type: ignore
        path_format_arguments = {
            'componentId': self._serialize.url("component_id", component_id, 'str'),
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 204, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 204:
            deserialized = self._deserialize('ComponentDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    delete_component.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/components/{componentId}'}  # type: ignore

    async def get_component_tasks(
        self,
        organization_id: str,
        project_id: str,
        component_id: str,
        **kwargs: Any
    ) -> Optional[Union["_models.ComponentTaskListDataResult", "_models.ErrorResult"]]:
        """Gets all Component Tasks.

        Gets all Component Tasks.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param component_id:
        :type component_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ComponentTaskListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ComponentTaskListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ComponentTaskListDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_component_tasks.metadata['url']  # type: ignore
        path_format_arguments = {
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
            'componentId': self._serialize.url("component_id", component_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ComponentTaskListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_component_tasks.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/components/{componentId}/tasks'}  # type: ignore

    async def create_component_task(
        self,
        organization_id: str,
        project_id: str,
        component_id: str,
        body: Optional["_models.ComponentTaskDefinition"] = None,
        **kwargs: Any
    ) -> Optional[Union["_models.ComponentTaskDataResult", "_models.StatusResult", "_models.ErrorResult"]]:
        """Creates a new Project Component Task.

        Creates a new Project Component Task.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param component_id:
        :type component_id: str
        :param body:
        :type body: ~teamcloud.models.ComponentTaskDefinition
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ComponentTaskDataResult or StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ComponentTaskDataResult or ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ComponentTaskDataResult", "_models.StatusResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_component_task.metadata['url']  # type: ignore
        path_format_arguments = {
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
            'componentId': self._serialize.url("component_id", component_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'ComponentTaskDefinition')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201, 202, 400, 401, 403, 404, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 201:
            deserialized = self._deserialize('ComponentTaskDataResult', pipeline_response)

        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_component_task.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/components/{componentId}/tasks'}  # type: ignore

    async def get_component_task(
        self,
        id: str,
        organization_id: str,
        project_id: str,
        component_id: str,
        **kwargs: Any
    ) -> Optional[Union["_models.ComponentTaskDataResult", "_models.ErrorResult"]]:
        """Gets the Component Task.

        Gets the Component Task.

        :param id:
        :type id: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param component_id:
        :type component_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ComponentTaskDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ComponentTaskDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ComponentTaskDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_component_task.metadata['url']  # type: ignore
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str'),
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
            'componentId': self._serialize.url("component_id", component_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ComponentTaskDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_component_task.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/components/{componentId}/tasks/{id}'}  # type: ignore

    async def get_component_templates(
        self,
        organization_id: str,
        project_id: str,
        **kwargs: Any
    ) -> Optional[Union["_models.ComponentTemplateListDataResult", "_models.ErrorResult"]]:
        """Gets all Component Templates for a Project.

        Gets all Component Templates for a Project.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ComponentTemplateListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ComponentTemplateListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ComponentTemplateListDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_component_templates.metadata['url']  # type: ignore
        path_format_arguments = {
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ComponentTemplateListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_component_templates.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/templates'}  # type: ignore

    async def get_component_template(
        self,
        id: str,
        organization_id: str,
        project_id: str,
        **kwargs: Any
    ) -> Optional[Union["_models.ComponentTemplateDataResult", "_models.ErrorResult"]]:
        """Gets the Component Template.

        Gets the Component Template.

        :param id:
        :type id: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ComponentTemplateDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ComponentTemplateDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ComponentTemplateDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_component_template.metadata['url']  # type: ignore
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str'),
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ComponentTemplateDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_component_template.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/templates/{id}'}  # type: ignore

    async def get_deployment_scopes(
        self,
        organization_id: str,
        **kwargs: Any
    ) -> Optional[Union["_models.DeploymentScopeListDataResult", "_models.ErrorResult"]]:
        """Gets all Deployment Scopes.

        Gets all Deployment Scopes.

        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: DeploymentScopeListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.DeploymentScopeListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.DeploymentScopeListDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_deployment_scopes.metadata['url']  # type: ignore
        path_format_arguments = {
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('DeploymentScopeListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_deployment_scopes.metadata = {'url': '/orgs/{organizationId}/scopes'}  # type: ignore

    async def create_deployment_scope(
        self,
        organization_id: str,
        body: Optional["_models.DeploymentScopeDefinition"] = None,
        **kwargs: Any
    ) -> Optional[Union["_models.DeploymentScopeDataResult", "_models.ErrorResult"]]:
        """Creates a new Deployment Scope.

        Creates a new Deployment Scope.

        :param organization_id:
        :type organization_id: str
        :param body:
        :type body: ~teamcloud.models.DeploymentScopeDefinition
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: DeploymentScopeDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.DeploymentScopeDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.DeploymentScopeDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_deployment_scope.metadata['url']  # type: ignore
        path_format_arguments = {
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'DeploymentScopeDefinition')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 401, 403, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 201:
            deserialized = self._deserialize('DeploymentScopeDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_deployment_scope.metadata = {'url': '/orgs/{organizationId}/scopes'}  # type: ignore

    async def get_deployment_scope(
        self,
        deployment_scope_id: str,
        organization_id: str,
        **kwargs: Any
    ) -> Optional[Union["_models.DeploymentScopeDataResult", "_models.ErrorResult"]]:
        """Gets a Deployment Scope.

        Gets a Deployment Scope.

        :param deployment_scope_id:
        :type deployment_scope_id: str
        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: DeploymentScopeDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.DeploymentScopeDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.DeploymentScopeDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_deployment_scope.metadata['url']  # type: ignore
        path_format_arguments = {
            'deploymentScopeId': self._serialize.url("deployment_scope_id", deployment_scope_id, 'str'),
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('DeploymentScopeDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_deployment_scope.metadata = {'url': '/orgs/{organizationId}/scopes/{deploymentScopeId}'}  # type: ignore

    async def update_deployment_scope(
        self,
        deployment_scope_id: str,
        organization_id: str,
        body: Optional["_models.DeploymentScope"] = None,
        **kwargs: Any
    ) -> Optional[Union["_models.DeploymentScopeDataResult", "_models.ErrorResult"]]:
        """Updates an existing Deployment Scope.

        Updates an existing Deployment Scope.

        :param deployment_scope_id:
        :type deployment_scope_id: str
        :param organization_id:
        :type organization_id: str
        :param body:
        :type body: ~teamcloud.models.DeploymentScope
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: DeploymentScopeDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.DeploymentScopeDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.DeploymentScopeDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_deployment_scope.metadata['url']  # type: ignore
        path_format_arguments = {
            'deploymentScopeId': self._serialize.url("deployment_scope_id", deployment_scope_id, 'str'),
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'DeploymentScope')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('DeploymentScopeDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_deployment_scope.metadata = {'url': '/orgs/{organizationId}/scopes/{deploymentScopeId}'}  # type: ignore

    async def delete_deployment_scope(
        self,
        deployment_scope_id: str,
        organization_id: str,
        **kwargs: Any
    ) -> Optional[Union["_models.DeploymentScopeDataResult", "_models.ErrorResult"]]:
        """Deletes a Deployment Scope.

        Deletes a Deployment Scope.

        :param deployment_scope_id:
        :type deployment_scope_id: str
        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: DeploymentScopeDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.DeploymentScopeDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.DeploymentScopeDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_deployment_scope.metadata['url']  # type: ignore
        path_format_arguments = {
            'deploymentScopeId': self._serialize.url("deployment_scope_id", deployment_scope_id, 'str'),
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 204:
            deserialized = self._deserialize('DeploymentScopeDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    delete_deployment_scope.metadata = {'url': '/orgs/{organizationId}/scopes/{deploymentScopeId}'}  # type: ignore

    async def authorize_deployment_scope(
        self,
        deployment_scope_id: str,
        organization_id: str,
        body: Optional["_models.DeploymentScope"] = None,
        **kwargs: Any
    ) -> Optional[Union["_models.DeploymentScopeDataResult", "_models.ErrorResult"]]:
        """Authorize an existing Deployment Scope.

        Authorize an existing Deployment Scope.

        :param deployment_scope_id:
        :type deployment_scope_id: str
        :param organization_id:
        :type organization_id: str
        :param body:
        :type body: ~teamcloud.models.DeploymentScope
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: DeploymentScopeDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.DeploymentScopeDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.DeploymentScopeDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json-patch+json")
        accept = "application/json"

        # Construct URL
        url = self.authorize_deployment_scope.metadata['url']  # type: ignore
        path_format_arguments = {
            'deploymentScopeId': self._serialize.url("deployment_scope_id", deployment_scope_id, 'str'),
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'DeploymentScope')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('DeploymentScopeDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    authorize_deployment_scope.metadata = {'url': '/orgs/{organizationId}/scopes/{deploymentScopeId}/authorize'}  # type: ignore

    async def negotiate_signal_r(
        self,
        organization_id: str,
        project_id: str,
        **kwargs: Any
    ) -> None:
        """Negotiates the SignalR connection.

        Negotiates the SignalR connection.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        # Construct URL
        url = self.negotiate_signal_r.metadata['url']  # type: ignore
        path_format_arguments = {
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]

        request = self._client.post(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    negotiate_signal_r.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/negotiate'}  # type: ignore

    async def get_audit_entries(
        self,
        organization_id: str,
        time_range: Optional[str] = None,
        commands: Optional[List[str]] = None,
        **kwargs: Any
    ) -> Optional[Union["_models.CommandAuditEntityListDataResult", "_models.ErrorResult"]]:
        """Gets all audit entries.

        Gets all audit entries.

        :param organization_id:
        :type organization_id: str
        :param time_range:
        :type time_range: str
        :param commands:
        :type commands: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: CommandAuditEntityListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.CommandAuditEntityListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.CommandAuditEntityListDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_audit_entries.metadata['url']  # type: ignore
        path_format_arguments = {
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if time_range is not None:
            query_parameters['timeRange'] = self._serialize.query("time_range", time_range, 'str')
        if commands is not None:
            query_parameters['commands'] = self._serialize.query("commands", commands, '[str]')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('CommandAuditEntityListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_audit_entries.metadata = {'url': '/orgs/{organizationId}/audit'}  # type: ignore

    async def get_audit_entry(
        self,
        command_id: str,
        organization_id: str,
        expand: Optional[bool] = False,
        **kwargs: Any
    ) -> Optional[Union["_models.CommandAuditEntityDataResult", "_models.ErrorResult"]]:
        """Gets an audit entry.

        Gets an audit entry.

        :param command_id:
        :type command_id: str
        :param organization_id:
        :type organization_id: str
        :param expand:
        :type expand: bool
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: CommandAuditEntityDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.CommandAuditEntityDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.CommandAuditEntityDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_audit_entry.metadata['url']  # type: ignore
        path_format_arguments = {
            'commandId': self._serialize.url("command_id", command_id, 'str'),
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]
        if expand is not None:
            query_parameters['expand'] = self._serialize.query("expand", expand, 'bool')

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('CommandAuditEntityDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_audit_entry.metadata = {'url': '/orgs/{organizationId}/audit/{commandId}'}  # type: ignore

    async def get_audit_commands(
        self,
        organization_id: str,
        **kwargs: Any
    ) -> Optional[Union["_models.StringListDataResult", "_models.ErrorResult"]]:
        """Gets all auditable commands.

        Gets all auditable commands.

        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StringListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StringListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.StringListDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_audit_commands.metadata['url']  # type: ignore
        path_format_arguments = {
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('StringListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_audit_commands.metadata = {'url': '/orgs/{organizationId}/audit/commands'}  # type: ignore

    async def get_organizations(
        self,
        **kwargs: Any
    ) -> Optional[Union["_models.OrganizationListDataResult", "_models.ErrorResult"]]:
        """Gets all Organizations.

        Gets all Organizations.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: OrganizationListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.OrganizationListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.OrganizationListDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_organizations.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('OrganizationListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_organizations.metadata = {'url': '/orgs'}  # type: ignore

    async def create_organization(
        self,
        body: Optional["_models.OrganizationDefinition"] = None,
        **kwargs: Any
    ) -> Optional[Union["_models.OrganizationDataResult", "_models.ErrorResult"]]:
        """Creates a new Organization.

        Creates a new Organization.

        :param body:
        :type body: ~teamcloud.models.OrganizationDefinition
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: OrganizationDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.OrganizationDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.OrganizationDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_organization.metadata['url']  # type: ignore

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'OrganizationDefinition')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 401, 403, 404, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 201:
            deserialized = self._deserialize('OrganizationDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_organization.metadata = {'url': '/orgs'}  # type: ignore

    async def get_organization(
        self,
        organization_id: str,
        **kwargs: Any
    ) -> Optional[Union["_models.OrganizationDataResult", "_models.ErrorResult"]]:
        """Gets an Organization.

        Gets an Organization.

        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: OrganizationDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.OrganizationDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.OrganizationDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_organization.metadata['url']  # type: ignore
        path_format_arguments = {
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('OrganizationDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_organization.metadata = {'url': '/orgs/{organizationId}'}  # type: ignore

    async def delete_organization(
        self,
        organization_id: str,
        **kwargs: Any
    ) -> Optional[Union["_models.StatusResult", "_models.ErrorResult"]]:
        """Deletes an existing Organization.

        Deletes an existing Organization.

        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.StatusResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_organization.metadata['url']  # type: ignore
        path_format_arguments = {
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    delete_organization.metadata = {'url': '/orgs/{organizationId}'}  # type: ignore

    async def get_organization_users(
        self,
        organization_id: str,
        **kwargs: Any
    ) -> Optional[Union["_models.UserListDataResult", "_models.ErrorResult"]]:
        """Gets all Users.

        Gets all Users.

        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UserListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.UserListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.UserListDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_organization_users.metadata['url']  # type: ignore
        path_format_arguments = {
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('UserListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_organization_users.metadata = {'url': '/orgs/{organizationId}/users'}  # type: ignore

    async def create_organization_user(
        self,
        organization_id: str,
        body: Optional["_models.UserDefinition"] = None,
        **kwargs: Any
    ) -> Optional[Union["_models.UserDataResult", "_models.ErrorResult"]]:
        """Creates a new User.

        Creates a new User.

        :param organization_id:
        :type organization_id: str
        :param body:
        :type body: ~teamcloud.models.UserDefinition
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UserDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.UserDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.UserDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_organization_user.metadata['url']  # type: ignore
        path_format_arguments = {
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'UserDefinition')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 401, 403, 404, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 201:
            deserialized = self._deserialize('UserDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_organization_user.metadata = {'url': '/orgs/{organizationId}/users'}  # type: ignore

    async def get_organization_user(
        self,
        user_id: str,
        organization_id: str,
        **kwargs: Any
    ) -> Optional[Union["_models.UserDataResult", "_models.ErrorResult"]]:
        """Gets a User.

        Gets a User.

        :param user_id:
        :type user_id: str
        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UserDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.UserDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.UserDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_organization_user.metadata['url']  # type: ignore
        path_format_arguments = {
            'userId': self._serialize.url("user_id", user_id, 'str'),
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('UserDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_organization_user.metadata = {'url': '/orgs/{organizationId}/users/{userId}'}  # type: ignore

    async def update_organization_user(
        self,
        user_id: str,
        organization_id: str,
        body: Optional["_models.User"] = None,
        **kwargs: Any
    ) -> Optional[Union["_models.StatusResult", "_models.ErrorResult"]]:
        """Updates an existing User.

        Updates an existing User.

        :param user_id:
        :type user_id: str
        :param organization_id:
        :type organization_id: str
        :param body:
        :type body: ~teamcloud.models.User
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.StatusResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_organization_user.metadata['url']  # type: ignore
        path_format_arguments = {
            'userId': self._serialize.url("user_id", user_id, 'str'),
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'User')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_organization_user.metadata = {'url': '/orgs/{organizationId}/users/{userId}'}  # type: ignore

    async def delete_organization_user(
        self,
        user_id: str,
        organization_id: str,
        **kwargs: Any
    ) -> Optional[Union["_models.StatusResult", "_models.ErrorResult"]]:
        """Deletes an existing User.

        Deletes an existing User.

        :param user_id:
        :type user_id: str
        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.StatusResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_organization_user.metadata['url']  # type: ignore
        path_format_arguments = {
            'userId': self._serialize.url("user_id", user_id, 'str'),
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    delete_organization_user.metadata = {'url': '/orgs/{organizationId}/users/{userId}'}  # type: ignore

    async def get_organization_user_me(
        self,
        organization_id: str,
        **kwargs: Any
    ) -> Optional[Union["_models.UserDataResult", "_models.ErrorResult"]]:
        """Gets a User A User matching the current authenticated user.

        Gets a User A User matching the current authenticated user.

        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UserDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.UserDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.UserDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_organization_user_me.metadata['url']  # type: ignore
        path_format_arguments = {
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('UserDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_organization_user_me.metadata = {'url': '/orgs/{organizationId}/me'}  # type: ignore

    async def update_organization_user_me(
        self,
        organization_id: str,
        body: Optional["_models.User"] = None,
        **kwargs: Any
    ) -> Optional[Union["_models.StatusResult", "_models.ErrorResult"]]:
        """Updates an existing User.

        Updates an existing User.

        :param organization_id:
        :type organization_id: str
        :param body:
        :type body: ~teamcloud.models.User
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.StatusResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_organization_user_me.metadata['url']  # type: ignore
        path_format_arguments = {
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'User')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_organization_user_me.metadata = {'url': '/orgs/{organizationId}/me'}  # type: ignore

    async def get_projects(
        self,
        organization_id: str,
        **kwargs: Any
    ) -> Optional[Union["_models.ProjectListDataResult", "_models.ErrorResult"]]:
        """Gets all Projects.

        Gets all Projects.

        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ProjectListDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_projects.metadata['url']  # type: ignore
        path_format_arguments = {
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProjectListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_projects.metadata = {'url': '/orgs/{organizationId}/projects'}  # type: ignore

    async def create_project(
        self,
        organization_id: str,
        body: Optional["_models.ProjectDefinition"] = None,
        **kwargs: Any
    ) -> Optional[Union["_models.ProjectDataResult", "_models.StatusResult", "_models.ErrorResult"]]:
        """Creates a new Project.

        Creates a new Project.

        :param organization_id:
        :type organization_id: str
        :param body:
        :type body: ~teamcloud.models.ProjectDefinition
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectDataResult or StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectDataResult or ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ProjectDataResult", "_models.StatusResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_project.metadata['url']  # type: ignore
        path_format_arguments = {
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'ProjectDefinition')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201, 202, 400, 401, 403, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 201:
            deserialized = self._deserialize('ProjectDataResult', pipeline_response)

        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_project.metadata = {'url': '/orgs/{organizationId}/projects'}  # type: ignore

    async def get_project(
        self,
        project_id: str,
        organization_id: str,
        **kwargs: Any
    ) -> Optional[Union["_models.ProjectDataResult", "_models.ErrorResult"]]:
        """Gets a Project.

        Gets a Project.

        :param project_id:
        :type project_id: str
        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ProjectDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_project.metadata['url']  # type: ignore
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str'),
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProjectDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_project.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}'}  # type: ignore

    async def delete_project(
        self,
        project_id: str,
        organization_id: str,
        **kwargs: Any
    ) -> Optional[Union["_models.StatusResult", "_models.ErrorResult"]]:
        """Deletes a Project.

        Deletes a Project.

        :param project_id:
        :type project_id: str
        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.StatusResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_project.metadata['url']  # type: ignore
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str'),
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    delete_project.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}'}  # type: ignore

    async def get_project_identities(
        self,
        organization_id: str,
        project_id: str,
        **kwargs: Any
    ) -> Optional[Union["_models.ProjectIdentityListDataResult", "_models.ErrorResult"]]:
        """Gets all Project Identities.

        Gets all Project Identities.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectIdentityListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectIdentityListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ProjectIdentityListDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_project_identities.metadata['url']  # type: ignore
        path_format_arguments = {
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProjectIdentityListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_project_identities.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/identities'}  # type: ignore

    async def create_project_identity(
        self,
        organization_id: str,
        project_id: str,
        body: Optional["_models.ProjectIdentityDefinition"] = None,
        **kwargs: Any
    ) -> Optional[Union["_models.ProjectIdentityDataResult", "_models.ErrorResult"]]:
        """Creates a new Project Identity.

        Creates a new Project Identity.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param body:
        :type body: ~teamcloud.models.ProjectIdentityDefinition
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectIdentityDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectIdentityDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ProjectIdentityDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_project_identity.metadata['url']  # type: ignore
        path_format_arguments = {
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'ProjectIdentityDefinition')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 401, 403, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 201:
            deserialized = self._deserialize('ProjectIdentityDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_project_identity.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/identities'}  # type: ignore

    async def get_project_identity(
        self,
        project_identity_id: str,
        organization_id: str,
        project_id: str,
        **kwargs: Any
    ) -> Optional[Union["_models.ProjectIdentityDataResult", "_models.ErrorResult"]]:
        """Gets a Project Identity.

        Gets a Project Identity.

        :param project_identity_id:
        :type project_identity_id: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectIdentityDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectIdentityDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ProjectIdentityDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_project_identity.metadata['url']  # type: ignore
        path_format_arguments = {
            'projectIdentityId': self._serialize.url("project_identity_id", project_identity_id, 'str'),
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProjectIdentityDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_project_identity.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/identities/{projectIdentityId}'}  # type: ignore

    async def update_project_identity(
        self,
        project_identity_id: str,
        organization_id: str,
        project_id: str,
        body: Optional["_models.ProjectIdentity"] = None,
        **kwargs: Any
    ) -> Optional[Union["_models.StatusResult", "_models.ErrorResult"]]:
        """Updates an existing Project Identity.

        Updates an existing Project Identity.

        :param project_identity_id:
        :type project_identity_id: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param body:
        :type body: ~teamcloud.models.ProjectIdentity
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.StatusResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_project_identity.metadata['url']  # type: ignore
        path_format_arguments = {
            'projectIdentityId': self._serialize.url("project_identity_id", project_identity_id, 'str'),
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'ProjectIdentity')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_project_identity.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/identities/{projectIdentityId}'}  # type: ignore

    async def delete_project_identity(
        self,
        project_identity_id: str,
        organization_id: str,
        project_id: str,
        **kwargs: Any
    ) -> Optional[Union["_models.ProjectIdentityDataResult", "_models.ErrorResult"]]:
        """Deletes a Project Identity.

        Deletes a Project Identity.

        :param project_identity_id:
        :type project_identity_id: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectIdentityDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectIdentityDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ProjectIdentityDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_project_identity.metadata['url']  # type: ignore
        path_format_arguments = {
            'projectIdentityId': self._serialize.url("project_identity_id", project_identity_id, 'str'),
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 204:
            deserialized = self._deserialize('ProjectIdentityDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    delete_project_identity.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/identities/{projectIdentityId}'}  # type: ignore

    async def get_project_tags(
        self,
        organization_id: str,
        project_id: str,
        **kwargs: Any
    ) -> Optional[Union["_models.StringDictionaryDataResult", "_models.ErrorResult"]]:
        """Gets all Tags for a Project.

        Gets all Tags for a Project.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StringDictionaryDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StringDictionaryDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.StringDictionaryDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_project_tags.metadata['url']  # type: ignore
        path_format_arguments = {
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('StringDictionaryDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_project_tags.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/tags'}  # type: ignore

    async def create_project_tag(
        self,
        organization_id: str,
        project_id: str,
        body: Optional[Dict[str, str]] = None,
        **kwargs: Any
    ) -> Optional[Union["_models.StatusResult", "_models.ErrorResult"]]:
        """Creates a new Project Tag.

        Creates a new Project Tag.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param body:
        :type body: dict[str, str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.StatusResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_project_tag.metadata['url']  # type: ignore
        path_format_arguments = {
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, '{str}')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 401, 403, 404, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_project_tag.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/tags'}  # type: ignore

    async def update_project_tag(
        self,
        organization_id: str,
        project_id: str,
        body: Optional[Dict[str, str]] = None,
        **kwargs: Any
    ) -> Optional[Union["_models.StatusResult", "_models.ErrorResult"]]:
        """Updates an existing Project Tag.

        Updates an existing Project Tag.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param body:
        :type body: dict[str, str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.StatusResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_project_tag.metadata['url']  # type: ignore
        path_format_arguments = {
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, '{str}')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_project_tag.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/tags'}  # type: ignore

    async def get_project_tag_by_key(
        self,
        tag_key: str,
        organization_id: str,
        project_id: str,
        **kwargs: Any
    ) -> Optional[Union["_models.StringDictionaryDataResult", "_models.ErrorResult"]]:
        """Gets a Project Tag by Key.

        Gets a Project Tag by Key.

        :param tag_key:
        :type tag_key: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StringDictionaryDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StringDictionaryDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.StringDictionaryDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_project_tag_by_key.metadata['url']  # type: ignore
        path_format_arguments = {
            'tagKey': self._serialize.url("tag_key", tag_key, 'str'),
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('StringDictionaryDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_project_tag_by_key.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/tags/{tagKey}'}  # type: ignore

    async def delete_project_tag(
        self,
        tag_key: str,
        organization_id: str,
        project_id: str,
        **kwargs: Any
    ) -> Optional[Union["_models.StatusResult", "_models.ErrorResult"]]:
        """Deletes an existing Project Tag.

        Deletes an existing Project Tag.

        :param tag_key:
        :type tag_key: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.StatusResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_project_tag.metadata['url']  # type: ignore
        path_format_arguments = {
            'tagKey': self._serialize.url("tag_key", tag_key, 'str'),
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    delete_project_tag.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/tags/{tagKey}'}  # type: ignore

    async def get_project_templates(
        self,
        organization_id: str,
        **kwargs: Any
    ) -> Optional[Union["_models.ProjectTemplateListDataResult", "_models.ErrorResult"]]:
        """Gets all Project Templates.

        Gets all Project Templates.

        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectTemplateListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectTemplateListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ProjectTemplateListDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_project_templates.metadata['url']  # type: ignore
        path_format_arguments = {
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProjectTemplateListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_project_templates.metadata = {'url': '/orgs/{organizationId}/templates'}  # type: ignore

    async def create_project_template(
        self,
        organization_id: str,
        body: Optional["_models.ProjectTemplateDefinition"] = None,
        **kwargs: Any
    ) -> Optional[Union["_models.ProjectTemplateDataResult", "_models.ErrorResult"]]:
        """Creates a new Project Template.

        Creates a new Project Template.

        :param organization_id:
        :type organization_id: str
        :param body:
        :type body: ~teamcloud.models.ProjectTemplateDefinition
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectTemplateDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectTemplateDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ProjectTemplateDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_project_template.metadata['url']  # type: ignore
        path_format_arguments = {
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'ProjectTemplateDefinition')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 401, 403, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 201:
            deserialized = self._deserialize('ProjectTemplateDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_project_template.metadata = {'url': '/orgs/{organizationId}/templates'}  # type: ignore

    async def get_project_template(
        self,
        project_template_id: str,
        organization_id: str,
        **kwargs: Any
    ) -> Optional[Union["_models.ProjectTemplateDataResult", "_models.ErrorResult"]]:
        """Gets a Project Template.

        Gets a Project Template.

        :param project_template_id:
        :type project_template_id: str
        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectTemplateDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectTemplateDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ProjectTemplateDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_project_template.metadata['url']  # type: ignore
        path_format_arguments = {
            'projectTemplateId': self._serialize.url("project_template_id", project_template_id, 'str'),
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProjectTemplateDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_project_template.metadata = {'url': '/orgs/{organizationId}/templates/{projectTemplateId}'}  # type: ignore

    async def update_project_template(
        self,
        project_template_id: str,
        organization_id: str,
        body: Optional["_models.ProjectTemplate"] = None,
        **kwargs: Any
    ) -> Optional[Union["_models.ProjectTemplateDataResult", "_models.ErrorResult"]]:
        """Updates an existing Project Template.

        Updates an existing Project Template.

        :param project_template_id:
        :type project_template_id: str
        :param organization_id:
        :type organization_id: str
        :param body:
        :type body: ~teamcloud.models.ProjectTemplate
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectTemplateDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectTemplateDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ProjectTemplateDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_project_template.metadata['url']  # type: ignore
        path_format_arguments = {
            'projectTemplateId': self._serialize.url("project_template_id", project_template_id, 'str'),
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'ProjectTemplate')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProjectTemplateDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_project_template.metadata = {'url': '/orgs/{organizationId}/templates/{projectTemplateId}'}  # type: ignore

    async def delete_project_template(
        self,
        project_template_id: str,
        organization_id: str,
        **kwargs: Any
    ) -> Optional[Union["_models.ProjectTemplateDataResult", "_models.ErrorResult"]]:
        """Deletes a Project Template.

        Deletes a Project Template.

        :param project_template_id:
        :type project_template_id: str
        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectTemplateDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectTemplateDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ProjectTemplateDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_project_template.metadata['url']  # type: ignore
        path_format_arguments = {
            'projectTemplateId': self._serialize.url("project_template_id", project_template_id, 'str'),
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 204:
            deserialized = self._deserialize('ProjectTemplateDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    delete_project_template.metadata = {'url': '/orgs/{organizationId}/templates/{projectTemplateId}'}  # type: ignore

    async def get_project_users(
        self,
        organization_id: str,
        project_id: str,
        **kwargs: Any
    ) -> Optional[Union["_models.UserListDataResult", "_models.ErrorResult"]]:
        """Gets all Users for a Project.

        Gets all Users for a Project.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UserListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.UserListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.UserListDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_project_users.metadata['url']  # type: ignore
        path_format_arguments = {
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('UserListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_project_users.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/users'}  # type: ignore

    async def create_project_user(
        self,
        organization_id: str,
        project_id: str,
        body: Optional["_models.UserDefinition"] = None,
        **kwargs: Any
    ) -> Optional[Union["_models.UserDataResult", "_models.StatusResult", "_models.ErrorResult"]]:
        """Creates a new Project User.

        Creates a new Project User.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param body:
        :type body: ~teamcloud.models.UserDefinition
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UserDataResult or StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.UserDataResult or ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.UserDataResult", "_models.StatusResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_project_user.metadata['url']  # type: ignore
        path_format_arguments = {
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'UserDefinition')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201, 202, 400, 401, 403, 404, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 201:
            deserialized = self._deserialize('UserDataResult', pipeline_response)

        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_project_user.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/users'}  # type: ignore

    async def get_project_user(
        self,
        user_id: str,
        organization_id: str,
        project_id: str,
        **kwargs: Any
    ) -> Optional[Union["_models.UserDataResult", "_models.ErrorResult"]]:
        """Gets a Project User by ID or email address.

        Gets a Project User by ID or email address.

        :param user_id:
        :type user_id: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UserDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.UserDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.UserDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_project_user.metadata['url']  # type: ignore
        path_format_arguments = {
            'userId': self._serialize.url("user_id", user_id, 'str'),
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('UserDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_project_user.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/users/{userId}'}  # type: ignore

    async def update_project_user(
        self,
        user_id: str,
        organization_id: str,
        project_id: str,
        body: Optional["_models.User"] = None,
        **kwargs: Any
    ) -> Optional[Union["_models.UserDataResult", "_models.StatusResult", "_models.ErrorResult"]]:
        """Updates an existing Project User.

        Updates an existing Project User.

        :param user_id:
        :type user_id: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param body:
        :type body: ~teamcloud.models.User
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UserDataResult or StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.UserDataResult or ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.UserDataResult", "_models.StatusResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_project_user.metadata['url']  # type: ignore
        path_format_arguments = {
            'userId': self._serialize.url("user_id", user_id, 'str'),
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'User')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('UserDataResult', pipeline_response)

        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_project_user.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/users/{userId}'}  # type: ignore

    async def delete_project_user(
        self,
        user_id: str,
        organization_id: str,
        project_id: str,
        **kwargs: Any
    ) -> Optional[Union["_models.StatusResult", "_models.ErrorResult"]]:
        """Deletes an existing Project User.

        Deletes an existing Project User.

        :param user_id:
        :type user_id: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.StatusResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.delete_project_user.metadata['url']  # type: ignore
        path_format_arguments = {
            'userId': self._serialize.url("user_id", user_id, 'str'),
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.delete(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    delete_project_user.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/users/{userId}'}  # type: ignore

    async def get_project_user_me(
        self,
        organization_id: str,
        project_id: str,
        **kwargs: Any
    ) -> Optional[Union["_models.UserDataResult", "_models.ErrorResult"]]:
        """Gets a Project User for the calling user.

        Gets a Project User for the calling user.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UserDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.UserDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.UserDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_project_user_me.metadata['url']  # type: ignore
        path_format_arguments = {
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('UserDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_project_user_me.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/users/me'}  # type: ignore

    async def update_project_user_me(
        self,
        organization_id: str,
        project_id: str,
        body: Optional["_models.User"] = None,
        **kwargs: Any
    ) -> Optional[Union["_models.UserDataResult", "_models.StatusResult", "_models.ErrorResult"]]:
        """Updates an existing Project User.

        Updates an existing Project User.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param body:
        :type body: ~teamcloud.models.User
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UserDataResult or StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.UserDataResult or ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.UserDataResult", "_models.StatusResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_project_user_me.metadata['url']  # type: ignore
        path_format_arguments = {
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'User')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('UserDataResult', pipeline_response)

        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_project_user_me.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/users/me'}  # type: ignore

    async def get_schedules(
        self,
        organization_id: str,
        project_id: str,
        **kwargs: Any
    ) -> Optional[Union["_models.ScheduleListDataResult", "_models.ErrorResult"]]:
        """Gets all Schedule.

        Gets all Schedule.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ScheduleListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ScheduleListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ScheduleListDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_schedules.metadata['url']  # type: ignore
        path_format_arguments = {
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ScheduleListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_schedules.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/schedules'}  # type: ignore

    async def create_schedule(
        self,
        organization_id: str,
        project_id: str,
        body: Optional["_models.ScheduleDefinition"] = None,
        **kwargs: Any
    ) -> Optional[Union["_models.ScheduleDataResult", "_models.ErrorResult"]]:
        """Creates a new Project Schedule.

        Creates a new Project Schedule.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param body:
        :type body: ~teamcloud.models.ScheduleDefinition
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ScheduleDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ScheduleDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ScheduleDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.create_schedule.metadata['url']  # type: ignore
        path_format_arguments = {
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'ScheduleDefinition')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.post(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 401, 403, 404, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 201:
            deserialized = self._deserialize('ScheduleDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    create_schedule.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/schedules'}  # type: ignore

    async def get_schedule(
        self,
        schedule_id: str,
        organization_id: str,
        project_id: str,
        **kwargs: Any
    ) -> Optional[Union["_models.ScheduleDataResult", "_models.ErrorResult"]]:
        """Gets the Schedule.

        Gets the Schedule.

        :param schedule_id:
        :type schedule_id: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ScheduleDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ScheduleDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ScheduleDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_schedule.metadata['url']  # type: ignore
        path_format_arguments = {
            'scheduleId': self._serialize.url("schedule_id", schedule_id, 'str'),
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ScheduleDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_schedule.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/schedules/{scheduleId}'}  # type: ignore

    async def update_schedule(
        self,
        schedule_id: str,
        organization_id: str,
        project_id: str,
        body: Optional["_models.Schedule"] = None,
        **kwargs: Any
    ) -> Optional[Union["_models.ScheduleDataResult", "_models.ErrorResult"]]:
        """Updates a Project Schedule.

        Updates a Project Schedule.

        :param schedule_id:
        :type schedule_id: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param body:
        :type body: ~teamcloud.models.Schedule
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ScheduleDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ScheduleDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ScheduleDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        content_type = kwargs.pop("content_type", "application/json")
        accept = "application/json"

        # Construct URL
        url = self.update_schedule.metadata['url']  # type: ignore
        path_format_arguments = {
            'scheduleId': self._serialize.url("schedule_id", schedule_id, 'str'),
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Content-Type'] = self._serialize.header("content_type", content_type, 'str')
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        body_content_kwargs = {}  # type: Dict[str, Any]
        if body is not None:
            body_content = self._serialize.body(body, 'Schedule')
        else:
            body_content = None
        body_content_kwargs['content'] = body_content
        request = self._client.put(url, query_parameters, header_parameters, **body_content_kwargs)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ScheduleDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    update_schedule.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/schedules/{scheduleId}'}  # type: ignore

    async def run_schedule(
        self,
        schedule_id: str,
        organization_id: str,
        project_id: str,
        **kwargs: Any
    ) -> Optional[Union["_models.ScheduleDataResult", "_models.ErrorResult"]]:
        """Runs a Project Schedule.

        Runs a Project Schedule.

        :param schedule_id:
        :type schedule_id: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ScheduleDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ScheduleDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ScheduleDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.run_schedule.metadata['url']  # type: ignore
        path_format_arguments = {
            'scheduleId': self._serialize.url("schedule_id", schedule_id, 'str'),
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
            'projectId': self._serialize.url("project_id", project_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.post(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ScheduleDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    run_schedule.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/schedules/{scheduleId}/run'}  # type: ignore

    async def get_status(
        self,
        tracking_id: str,
        organization_id: str,
        **kwargs: Any
    ) -> Optional[Union["_models.StatusResult", "_models.ErrorResult"]]:
        """Gets the status of a long-running operation.

        Gets the status of a long-running operation.

        :param tracking_id:
        :type tracking_id: str
        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.StatusResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_status.metadata['url']  # type: ignore
        path_format_arguments = {
            'trackingId': self._serialize.url("tracking_id", tracking_id, 'str'),
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 302, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 302:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_status.metadata = {'url': '/orgs/{organizationId}/status/{trackingId}'}  # type: ignore

    async def get_project_status(
        self,
        project_id: str,
        tracking_id: str,
        organization_id: str,
        **kwargs: Any
    ) -> Optional[Union["_models.StatusResult", "_models.ErrorResult"]]:
        """Gets the status of a long-running operation.

        Gets the status of a long-running operation.

        :param project_id:
        :type project_id: str
        :param tracking_id:
        :type tracking_id: str
        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.StatusResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_project_status.metadata['url']  # type: ignore
        path_format_arguments = {
            'projectId': self._serialize.url("project_id", project_id, 'str'),
            'trackingId': self._serialize.url("tracking_id", tracking_id, 'str'),
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 302, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 302:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_project_status.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/status/{trackingId}'}  # type: ignore

    async def get_user_projects(
        self,
        organization_id: str,
        user_id: str,
        **kwargs: Any
    ) -> Optional[Union["_models.ProjectListDataResult", "_models.ErrorResult"]]:
        """Gets all Projects for a User.

        Gets all Projects for a User.

        :param organization_id:
        :type organization_id: str
        :param user_id:
        :type user_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ProjectListDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_user_projects.metadata['url']  # type: ignore
        path_format_arguments = {
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
            'userId': self._serialize.url("user_id", user_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProjectListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_user_projects.metadata = {'url': '/orgs/{organizationId}/users/{userId}/projects'}  # type: ignore

    async def get_user_projects_me(
        self,
        organization_id: str,
        **kwargs: Any
    ) -> Optional[Union["_models.ProjectListDataResult", "_models.ErrorResult"]]:
        """Gets all Projects for a User.

        Gets all Projects for a User.

        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ProjectListDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))
        accept = "application/json"

        # Construct URL
        url = self.get_user_projects_me.metadata['url']  # type: ignore
        path_format_arguments = {
            'organizationId': self._serialize.url("organization_id", organization_id, 'str'),
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}  # type: Dict[str, Any]

        # Construct headers
        header_parameters = {}  # type: Dict[str, Any]
        header_parameters['Accept'] = self._serialize.header("accept", accept, 'str')

        request = self._client.get(url, query_parameters, header_parameters)
        pipeline_response = await self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProjectListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized
    get_user_projects_me.metadata = {'url': '/orgs/{organizationId}/me/projects'}  # type: ignore
