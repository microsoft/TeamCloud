# pylint: disable=too-many-lines
# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
from typing import Any, Callable, Dict, List, Optional, TypeVar, Union

from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import AsyncHttpResponse
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator_async import distributed_trace_async
from azure.core.utils import case_insensitive_dict

from ... import models as _models
from ..._vendor import _convert_request
from ...operations._team_cloud_client_operations import build_cancel_component_task_request, build_create_component_request, build_create_component_task_request, build_create_deployment_scope_request, build_create_organization_request, build_create_organization_user_request, build_create_project_identity_request, build_create_project_request, build_create_project_tag_request, build_create_project_template_request, build_create_project_user_request, build_create_schedule_request, build_delete_component_request, build_delete_deployment_scope_request, build_delete_organization_request, build_delete_organization_user_request, build_delete_project_identity_request, build_delete_project_request, build_delete_project_tag_request, build_delete_project_template_request, build_delete_project_user_request, build_get_adapters_request, build_get_audit_commands_request, build_get_audit_entries_request, build_get_audit_entry_request, build_get_component_request, build_get_component_task_request, build_get_component_tasks_request, build_get_component_template_request, build_get_component_templates_request, build_get_components_request, build_get_deployment_scope_request, build_get_deployment_scopes_request, build_get_info_request, build_get_organization_request, build_get_organization_user_me_request, build_get_organization_user_request, build_get_organization_users_request, build_get_organizations_request, build_get_project_identities_request, build_get_project_identity_request, build_get_project_request, build_get_project_status_request, build_get_project_tag_by_key_request, build_get_project_tags_request, build_get_project_template_request, build_get_project_templates_request, build_get_project_user_me_request, build_get_project_user_request, build_get_project_users_request, build_get_projects_request, build_get_schedule_request, build_get_schedules_request, build_get_status_request, build_get_user_projects_me_request, build_get_user_projects_request, build_initialize_authorization_request, build_negotiate_signal_r_request, build_re_run_component_task_request, build_run_schedule_request, build_update_deployment_scope_request, build_update_organization_user_me_request, build_update_organization_user_request, build_update_project_identity_request, build_update_project_tag_request, build_update_project_template_request, build_update_project_user_me_request, build_update_project_user_request, build_update_schedule_request
T = TypeVar('T')
ClsType = Optional[Callable[[PipelineResponse[HttpRequest, AsyncHttpResponse], T, Dict[str, Any]], Any]]

class TeamCloudClientOperationsMixin:  # pylint: disable=too-many-public-methods

    @distributed_trace_async
    async def get_adapters(
        self,
        **kwargs: Any
    ) -> Optional[Union[_models.AdapterInformationListDataResult, _models.ErrorResult]]:
        """Gets all Adapters.

        Gets all Adapters.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: AdapterInformationListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.AdapterInformationListDataResult or ~teamcloud.models.ErrorResult or
         None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.AdapterInformationListDataResult, _models.ErrorResult]]]

        
        request = build_get_adapters_request(
            template_url=self.get_adapters.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('AdapterInformationListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_adapters.metadata = {'url': "/adapters"}  # type: ignore


    @distributed_trace_async
    async def get_components(
        self,
        organization_id: str,
        project_id: str,
        deleted: Optional[bool] = False,
        **kwargs: Any
    ) -> Optional[Union[_models.ComponentListDataResult, _models.ErrorResult]]:
        """Gets all Components for a Project.

        Gets all Components for a Project.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param deleted:  Default value is False.
        :type deleted: bool
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ComponentListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ComponentListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.ComponentListDataResult, _models.ErrorResult]]]

        
        request = build_get_components_request(
            organization_id=organization_id,
            project_id=project_id,
            deleted=deleted,
            template_url=self.get_components.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ComponentListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_components.metadata = {'url': "/orgs/{organizationId}/projects/{projectId}/components"}  # type: ignore


    @distributed_trace_async
    async def create_component(
        self,
        organization_id: str,
        project_id: str,
        body: Optional[_models.ComponentDefinition] = None,
        **kwargs: Any
    ) -> Optional[Union[_models.ComponentDataResult, _models.StatusResult, _models.ErrorResult]]:
        """Creates a new Project Component.

        Creates a new Project Component.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param body:  Default value is None.
        :type body: ~teamcloud.models.ComponentDefinition
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ComponentDataResult or StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ComponentDataResult or ~teamcloud.models.StatusResult or
         ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.ComponentDataResult, _models.StatusResult, _models.ErrorResult]]]

        if body is not None:
            _json = self._serialize.body(body, 'ComponentDefinition')
        else:
            _json = None

        request = build_create_component_request(
            organization_id=organization_id,
            project_id=project_id,
            content_type=content_type,
            json=_json,
            template_url=self.create_component.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201, 202, 400, 401, 403, 404, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 201:
            deserialized = self._deserialize('ComponentDataResult', pipeline_response)

        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_component.metadata = {'url': "/orgs/{organizationId}/projects/{projectId}/components"}  # type: ignore


    @distributed_trace_async
    async def get_component(
        self,
        component_id: str,
        organization_id: str,
        project_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.ComponentDataResult, _models.ErrorResult]]:
        """Gets a Project Component.

        Gets a Project Component.

        :param component_id:
        :type component_id: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ComponentDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ComponentDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.ComponentDataResult, _models.ErrorResult]]]

        
        request = build_get_component_request(
            component_id=component_id,
            organization_id=organization_id,
            project_id=project_id,
            template_url=self.get_component.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ComponentDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_component.metadata = {'url': "/orgs/{organizationId}/projects/{projectId}/components/{componentId}"}  # type: ignore


    @distributed_trace_async
    async def delete_component(
        self,
        component_id: str,
        organization_id: str,
        project_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.StatusResult, _models.ComponentDataResult, _models.ErrorResult]]:
        """Deletes an existing Project Component.

        Deletes an existing Project Component.

        :param component_id:
        :type component_id: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ComponentDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ComponentDataResult or
         ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.StatusResult, _models.ComponentDataResult, _models.ErrorResult]]]

        
        request = build_delete_component_request(
            component_id=component_id,
            organization_id=organization_id,
            project_id=project_id,
            template_url=self.delete_component.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202, 204, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 204:
            deserialized = self._deserialize('ComponentDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    delete_component.metadata = {'url': "/orgs/{organizationId}/projects/{projectId}/components/{componentId}"}  # type: ignore


    @distributed_trace_async
    async def get_component_tasks(
        self,
        organization_id: str,
        project_id: str,
        component_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.ComponentTaskListDataResult, _models.ErrorResult]]:
        """Gets all Component Tasks.

        Gets all Component Tasks.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param component_id:
        :type component_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ComponentTaskListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ComponentTaskListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.ComponentTaskListDataResult, _models.ErrorResult]]]

        
        request = build_get_component_tasks_request(
            organization_id=organization_id,
            project_id=project_id,
            component_id=component_id,
            template_url=self.get_component_tasks.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ComponentTaskListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_component_tasks.metadata = {'url': "/orgs/{organizationId}/projects/{projectId}/components/{componentId}/tasks"}  # type: ignore


    @distributed_trace_async
    async def create_component_task(
        self,
        organization_id: str,
        project_id: str,
        component_id: str,
        body: Optional[_models.ComponentTaskDefinition] = None,
        **kwargs: Any
    ) -> Optional[Union[_models.ComponentTaskDataResult, _models.StatusResult, _models.ErrorResult]]:
        """Creates a new Project Component Task.

        Creates a new Project Component Task.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param component_id:
        :type component_id: str
        :param body:  Default value is None.
        :type body: ~teamcloud.models.ComponentTaskDefinition
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ComponentTaskDataResult or StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ComponentTaskDataResult or ~teamcloud.models.StatusResult or
         ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.ComponentTaskDataResult, _models.StatusResult, _models.ErrorResult]]]

        if body is not None:
            _json = self._serialize.body(body, 'ComponentTaskDefinition')
        else:
            _json = None

        request = build_create_component_task_request(
            organization_id=organization_id,
            project_id=project_id,
            component_id=component_id,
            content_type=content_type,
            json=_json,
            template_url=self.create_component_task.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201, 202, 400, 401, 403, 404, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 201:
            deserialized = self._deserialize('ComponentTaskDataResult', pipeline_response)

        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_component_task.metadata = {'url': "/orgs/{organizationId}/projects/{projectId}/components/{componentId}/tasks"}  # type: ignore


    @distributed_trace_async
    async def get_component_task(
        self,
        task_id: str,
        organization_id: str,
        project_id: str,
        component_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.ComponentTaskDataResult, _models.ErrorResult]]:
        """Gets the Component Task.

        Gets the Component Task.

        :param task_id:
        :type task_id: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param component_id:
        :type component_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ComponentTaskDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ComponentTaskDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.ComponentTaskDataResult, _models.ErrorResult]]]

        
        request = build_get_component_task_request(
            task_id=task_id,
            organization_id=organization_id,
            project_id=project_id,
            component_id=component_id,
            template_url=self.get_component_task.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ComponentTaskDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_component_task.metadata = {'url': "/orgs/{organizationId}/projects/{projectId}/components/{componentId}/tasks/{taskId}"}  # type: ignore


    @distributed_trace_async
    async def cancel_component_task(
        self,
        organization_id: str,
        project_id: str,
        component_id: str,
        task_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.ComponentTaskDataResult, _models.StatusResult, _models.ErrorResult]]:
        """Rerun a Project Component Task.

        Rerun a Project Component Task.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param component_id:
        :type component_id: str
        :param task_id:
        :type task_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ComponentTaskDataResult or StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ComponentTaskDataResult or ~teamcloud.models.StatusResult or
         ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.ComponentTaskDataResult, _models.StatusResult, _models.ErrorResult]]]

        
        request = build_cancel_component_task_request(
            organization_id=organization_id,
            project_id=project_id,
            component_id=component_id,
            task_id=task_id,
            template_url=self.cancel_component_task.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ComponentTaskDataResult', pipeline_response)

        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    cancel_component_task.metadata = {'url': "/orgs/{organizationId}/projects/{projectId}/components/{componentId}/tasks/{taskId}/cancel"}  # type: ignore


    @distributed_trace_async
    async def re_run_component_task(
        self,
        organization_id: str,
        project_id: str,
        component_id: str,
        task_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.ComponentTaskDataResult, _models.StatusResult, _models.ErrorResult]]:
        """Cancel an active Project Component Task.

        Cancel an active Project Component Task.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param component_id:
        :type component_id: str
        :param task_id:
        :type task_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ComponentTaskDataResult or StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ComponentTaskDataResult or ~teamcloud.models.StatusResult or
         ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.ComponentTaskDataResult, _models.StatusResult, _models.ErrorResult]]]

        
        request = build_re_run_component_task_request(
            organization_id=organization_id,
            project_id=project_id,
            component_id=component_id,
            task_id=task_id,
            template_url=self.re_run_component_task.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201, 202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 201:
            deserialized = self._deserialize('ComponentTaskDataResult', pipeline_response)

        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    re_run_component_task.metadata = {'url': "/orgs/{organizationId}/projects/{projectId}/components/{componentId}/tasks/{taskId}/rerun"}  # type: ignore


    @distributed_trace_async
    async def get_component_templates(
        self,
        organization_id: str,
        project_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.ComponentTemplateListDataResult, _models.ErrorResult]]:
        """Gets all Component Templates for a Project.

        Gets all Component Templates for a Project.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ComponentTemplateListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ComponentTemplateListDataResult or ~teamcloud.models.ErrorResult or
         None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.ComponentTemplateListDataResult, _models.ErrorResult]]]

        
        request = build_get_component_templates_request(
            organization_id=organization_id,
            project_id=project_id,
            template_url=self.get_component_templates.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ComponentTemplateListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_component_templates.metadata = {'url': "/orgs/{organizationId}/projects/{projectId}/templates"}  # type: ignore


    @distributed_trace_async
    async def get_component_template(
        self,
        id: str,
        organization_id: str,
        project_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.ComponentTemplateDataResult, _models.ErrorResult]]:
        """Gets the Component Template.

        Gets the Component Template.

        :param id:
        :type id: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ComponentTemplateDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ComponentTemplateDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.ComponentTemplateDataResult, _models.ErrorResult]]]

        
        request = build_get_component_template_request(
            id=id,
            organization_id=organization_id,
            project_id=project_id,
            template_url=self.get_component_template.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ComponentTemplateDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_component_template.metadata = {'url': "/orgs/{organizationId}/projects/{projectId}/templates/{id}"}  # type: ignore


    @distributed_trace_async
    async def get_deployment_scopes(
        self,
        organization_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.DeploymentScopeListDataResult, _models.ErrorResult]]:
        """Gets all Deployment Scopes.

        Gets all Deployment Scopes.

        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: DeploymentScopeListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.DeploymentScopeListDataResult or ~teamcloud.models.ErrorResult or
         None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.DeploymentScopeListDataResult, _models.ErrorResult]]]

        
        request = build_get_deployment_scopes_request(
            organization_id=organization_id,
            template_url=self.get_deployment_scopes.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('DeploymentScopeListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_deployment_scopes.metadata = {'url': "/orgs/{organizationId}/scopes"}  # type: ignore


    @distributed_trace_async
    async def create_deployment_scope(
        self,
        organization_id: str,
        body: Optional[_models.DeploymentScopeDefinition] = None,
        **kwargs: Any
    ) -> Optional[Union[_models.DeploymentScopeDataResult, _models.ErrorResult]]:
        """Creates a new Deployment Scope.

        Creates a new Deployment Scope.

        :param organization_id:
        :type organization_id: str
        :param body:  Default value is None.
        :type body: ~teamcloud.models.DeploymentScopeDefinition
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: DeploymentScopeDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.DeploymentScopeDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.DeploymentScopeDataResult, _models.ErrorResult]]]

        if body is not None:
            _json = self._serialize.body(body, 'DeploymentScopeDefinition')
        else:
            _json = None

        request = build_create_deployment_scope_request(
            organization_id=organization_id,
            content_type=content_type,
            json=_json,
            template_url=self.create_deployment_scope.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 401, 403, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 201:
            deserialized = self._deserialize('DeploymentScopeDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_deployment_scope.metadata = {'url': "/orgs/{organizationId}/scopes"}  # type: ignore


    @distributed_trace_async
    async def get_deployment_scope(
        self,
        organization_id: str,
        deployment_scope_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.DeploymentScopeDataResult, _models.ErrorResult]]:
        """Gets a Deployment Scope.

        Gets a Deployment Scope.

        :param organization_id:
        :type organization_id: str
        :param deployment_scope_id:
        :type deployment_scope_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: DeploymentScopeDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.DeploymentScopeDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.DeploymentScopeDataResult, _models.ErrorResult]]]

        
        request = build_get_deployment_scope_request(
            organization_id=organization_id,
            deployment_scope_id=deployment_scope_id,
            template_url=self.get_deployment_scope.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('DeploymentScopeDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_deployment_scope.metadata = {'url': "/orgs/{organizationId}/scopes/{deploymentScopeId}"}  # type: ignore


    @distributed_trace_async
    async def update_deployment_scope(
        self,
        organization_id: str,
        deployment_scope_id: str,
        body: Optional[_models.DeploymentScope] = None,
        **kwargs: Any
    ) -> Optional[Union[_models.DeploymentScopeDataResult, _models.ErrorResult]]:
        """Updates an existing Deployment Scope.

        Updates an existing Deployment Scope.

        :param organization_id:
        :type organization_id: str
        :param deployment_scope_id:
        :type deployment_scope_id: str
        :param body:  Default value is None.
        :type body: ~teamcloud.models.DeploymentScope
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: DeploymentScopeDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.DeploymentScopeDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.DeploymentScopeDataResult, _models.ErrorResult]]]

        if body is not None:
            _json = self._serialize.body(body, 'DeploymentScope')
        else:
            _json = None

        request = build_update_deployment_scope_request(
            organization_id=organization_id,
            deployment_scope_id=deployment_scope_id,
            content_type=content_type,
            json=_json,
            template_url=self.update_deployment_scope.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('DeploymentScopeDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_deployment_scope.metadata = {'url': "/orgs/{organizationId}/scopes/{deploymentScopeId}"}  # type: ignore


    @distributed_trace_async
    async def delete_deployment_scope(
        self,
        organization_id: str,
        deployment_scope_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.DeploymentScopeDataResult, _models.ErrorResult]]:
        """Deletes a Deployment Scope.

        Deletes a Deployment Scope.

        :param organization_id:
        :type organization_id: str
        :param deployment_scope_id:
        :type deployment_scope_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: DeploymentScopeDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.DeploymentScopeDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.DeploymentScopeDataResult, _models.ErrorResult]]]

        
        request = build_delete_deployment_scope_request(
            organization_id=organization_id,
            deployment_scope_id=deployment_scope_id,
            template_url=self.delete_deployment_scope.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [204, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 204:
            deserialized = self._deserialize('DeploymentScopeDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    delete_deployment_scope.metadata = {'url': "/orgs/{organizationId}/scopes/{deploymentScopeId}"}  # type: ignore


    @distributed_trace_async
    async def initialize_authorization(
        self,
        organization_id: str,
        deployment_scope_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.DeploymentScopeDataResult, _models.ErrorResult]]:
        """Initialize a new authorization session for a deployment scope.

        Initialize a new authorization session for a deployment scope.

        :param organization_id:
        :type organization_id: str
        :param deployment_scope_id:
        :type deployment_scope_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: DeploymentScopeDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.DeploymentScopeDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.DeploymentScopeDataResult, _models.ErrorResult]]]

        
        request = build_initialize_authorization_request(
            organization_id=organization_id,
            deployment_scope_id=deployment_scope_id,
            template_url=self.initialize_authorization.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('DeploymentScopeDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    initialize_authorization.metadata = {'url': "/orgs/{organizationId}/scopes/{deploymentScopeId}/authorize/initialize"}  # type: ignore


    @distributed_trace_async
    async def negotiate_signal_r(  # pylint: disable=inconsistent-return-statements
        self,
        organization_id: str,
        project_id: str,
        **kwargs: Any
    ) -> None:
        """Negotiates the SignalR connection.

        Negotiates the SignalR connection.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[None]

        
        request = build_negotiate_signal_r_request(
            organization_id=organization_id,
            project_id=project_id,
            template_url=self.negotiate_signal_r.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    negotiate_signal_r.metadata = {'url': "/orgs/{organizationId}/projects/{projectId}/negotiate"}  # type: ignore


    @distributed_trace_async
    async def get_audit_entries(
        self,
        organization_id: str,
        time_range: Optional[str] = None,
        commands: Optional[List[str]] = None,
        **kwargs: Any
    ) -> Optional[Union[_models.CommandAuditEntityListDataResult, _models.ErrorResult]]:
        """Gets all audit entries.

        Gets all audit entries.

        :param organization_id:
        :type organization_id: str
        :param time_range:  Default value is None.
        :type time_range: str
        :param commands:  Default value is None.
        :type commands: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: CommandAuditEntityListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.CommandAuditEntityListDataResult or ~teamcloud.models.ErrorResult or
         None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.CommandAuditEntityListDataResult, _models.ErrorResult]]]

        
        request = build_get_audit_entries_request(
            organization_id=organization_id,
            time_range=time_range,
            commands=commands,
            template_url=self.get_audit_entries.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('CommandAuditEntityListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_audit_entries.metadata = {'url': "/orgs/{organizationId}/audit"}  # type: ignore


    @distributed_trace_async
    async def get_audit_entry(
        self,
        command_id: str,
        organization_id: str,
        expand: Optional[bool] = False,
        **kwargs: Any
    ) -> Optional[Union[_models.CommandAuditEntityDataResult, _models.ErrorResult]]:
        """Gets an audit entry.

        Gets an audit entry.

        :param command_id:
        :type command_id: str
        :param organization_id:
        :type organization_id: str
        :param expand:  Default value is False.
        :type expand: bool
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: CommandAuditEntityDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.CommandAuditEntityDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.CommandAuditEntityDataResult, _models.ErrorResult]]]

        
        request = build_get_audit_entry_request(
            command_id=command_id,
            organization_id=organization_id,
            expand=expand,
            template_url=self.get_audit_entry.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('CommandAuditEntityDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_audit_entry.metadata = {'url': "/orgs/{organizationId}/audit/{commandId}"}  # type: ignore


    @distributed_trace_async
    async def get_audit_commands(
        self,
        organization_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.StringListDataResult, _models.ErrorResult]]:
        """Gets all auditable commands.

        Gets all auditable commands.

        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StringListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StringListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.StringListDataResult, _models.ErrorResult]]]

        
        request = build_get_audit_commands_request(
            organization_id=organization_id,
            template_url=self.get_audit_commands.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('StringListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_audit_commands.metadata = {'url': "/orgs/{organizationId}/audit/commands"}  # type: ignore


    @distributed_trace_async
    async def get_organizations(
        self,
        **kwargs: Any
    ) -> Optional[Union[_models.OrganizationListDataResult, _models.ErrorResult]]:
        """Gets all Organizations.

        Gets all Organizations.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: OrganizationListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.OrganizationListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.OrganizationListDataResult, _models.ErrorResult]]]

        
        request = build_get_organizations_request(
            template_url=self.get_organizations.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('OrganizationListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_organizations.metadata = {'url': "/orgs"}  # type: ignore


    @distributed_trace_async
    async def create_organization(
        self,
        body: Optional[_models.OrganizationDefinition] = None,
        **kwargs: Any
    ) -> Optional[Union[_models.OrganizationDataResult, _models.ErrorResult]]:
        """Creates a new Organization.

        Creates a new Organization.

        :param body:  Default value is None.
        :type body: ~teamcloud.models.OrganizationDefinition
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: OrganizationDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.OrganizationDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.OrganizationDataResult, _models.ErrorResult]]]

        if body is not None:
            _json = self._serialize.body(body, 'OrganizationDefinition')
        else:
            _json = None

        request = build_create_organization_request(
            content_type=content_type,
            json=_json,
            template_url=self.create_organization.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 401, 403, 404, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 201:
            deserialized = self._deserialize('OrganizationDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_organization.metadata = {'url': "/orgs"}  # type: ignore


    @distributed_trace_async
    async def get_organization(
        self,
        organization_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.OrganizationDataResult, _models.ErrorResult]]:
        """Gets an Organization.

        Gets an Organization.

        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: OrganizationDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.OrganizationDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.OrganizationDataResult, _models.ErrorResult]]]

        
        request = build_get_organization_request(
            organization_id=organization_id,
            template_url=self.get_organization.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('OrganizationDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_organization.metadata = {'url': "/orgs/{organizationId}"}  # type: ignore


    @distributed_trace_async
    async def delete_organization(
        self,
        organization_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.StatusResult, _models.ErrorResult]]:
        """Deletes an existing Organization.

        Deletes an existing Organization.

        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.StatusResult, _models.ErrorResult]]]

        
        request = build_delete_organization_request(
            organization_id=organization_id,
            template_url=self.delete_organization.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    delete_organization.metadata = {'url': "/orgs/{organizationId}"}  # type: ignore


    @distributed_trace_async
    async def get_organization_users(
        self,
        organization_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.UserListDataResult, _models.ErrorResult]]:
        """Gets all Users.

        Gets all Users.

        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UserListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.UserListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.UserListDataResult, _models.ErrorResult]]]

        
        request = build_get_organization_users_request(
            organization_id=organization_id,
            template_url=self.get_organization_users.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('UserListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_organization_users.metadata = {'url': "/orgs/{organizationId}/users"}  # type: ignore


    @distributed_trace_async
    async def create_organization_user(
        self,
        organization_id: str,
        body: Optional[_models.UserDefinition] = None,
        **kwargs: Any
    ) -> Optional[Union[_models.UserDataResult, _models.ErrorResult]]:
        """Creates a new User.

        Creates a new User.

        :param organization_id:
        :type organization_id: str
        :param body:  Default value is None.
        :type body: ~teamcloud.models.UserDefinition
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UserDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.UserDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.UserDataResult, _models.ErrorResult]]]

        if body is not None:
            _json = self._serialize.body(body, 'UserDefinition')
        else:
            _json = None

        request = build_create_organization_user_request(
            organization_id=organization_id,
            content_type=content_type,
            json=_json,
            template_url=self.create_organization_user.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 401, 403, 404, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 201:
            deserialized = self._deserialize('UserDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_organization_user.metadata = {'url': "/orgs/{organizationId}/users"}  # type: ignore


    @distributed_trace_async
    async def get_organization_user(
        self,
        user_id: str,
        organization_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.UserDataResult, _models.ErrorResult]]:
        """Gets a User.

        Gets a User.

        :param user_id:
        :type user_id: str
        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UserDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.UserDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.UserDataResult, _models.ErrorResult]]]

        
        request = build_get_organization_user_request(
            user_id=user_id,
            organization_id=organization_id,
            template_url=self.get_organization_user.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('UserDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_organization_user.metadata = {'url': "/orgs/{organizationId}/users/{userId}"}  # type: ignore


    @distributed_trace_async
    async def update_organization_user(
        self,
        user_id: str,
        organization_id: str,
        body: Optional[_models.User] = None,
        **kwargs: Any
    ) -> Optional[Union[_models.UserDataResult, _models.StatusResult, _models.ErrorResult]]:
        """Updates an existing User.

        Updates an existing User.

        :param user_id:
        :type user_id: str
        :param organization_id:
        :type organization_id: str
        :param body:  Default value is None.
        :type body: ~teamcloud.models.User
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UserDataResult or StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.UserDataResult or ~teamcloud.models.StatusResult or
         ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.UserDataResult, _models.StatusResult, _models.ErrorResult]]]

        if body is not None:
            _json = self._serialize.body(body, 'User')
        else:
            _json = None

        request = build_update_organization_user_request(
            user_id=user_id,
            organization_id=organization_id,
            content_type=content_type,
            json=_json,
            template_url=self.update_organization_user.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('UserDataResult', pipeline_response)

        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_organization_user.metadata = {'url': "/orgs/{organizationId}/users/{userId}"}  # type: ignore


    @distributed_trace_async
    async def delete_organization_user(
        self,
        user_id: str,
        organization_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.StatusResult, _models.UserDataResult, _models.ErrorResult]]:
        """Deletes an existing User.

        Deletes an existing User.

        :param user_id:
        :type user_id: str
        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or UserDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.UserDataResult or
         ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.StatusResult, _models.UserDataResult, _models.ErrorResult]]]

        
        request = build_delete_organization_user_request(
            user_id=user_id,
            organization_id=organization_id,
            template_url=self.delete_organization_user.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202, 204, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 204:
            deserialized = self._deserialize('UserDataResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    delete_organization_user.metadata = {'url': "/orgs/{organizationId}/users/{userId}"}  # type: ignore


    @distributed_trace_async
    async def get_organization_user_me(
        self,
        organization_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.UserDataResult, _models.ErrorResult]]:
        """Gets a User A User matching the current authenticated user.

        Gets a User A User matching the current authenticated user.

        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UserDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.UserDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.UserDataResult, _models.ErrorResult]]]

        
        request = build_get_organization_user_me_request(
            organization_id=organization_id,
            template_url=self.get_organization_user_me.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('UserDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_organization_user_me.metadata = {'url': "/orgs/{organizationId}/me"}  # type: ignore


    @distributed_trace_async
    async def update_organization_user_me(
        self,
        organization_id: str,
        body: Optional[_models.User] = None,
        **kwargs: Any
    ) -> Optional[Union[_models.UserDataResult, _models.StatusResult, _models.ErrorResult]]:
        """Updates an existing User.

        Updates an existing User.

        :param organization_id:
        :type organization_id: str
        :param body:  Default value is None.
        :type body: ~teamcloud.models.User
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UserDataResult or StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.UserDataResult or ~teamcloud.models.StatusResult or
         ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.UserDataResult, _models.StatusResult, _models.ErrorResult]]]

        if body is not None:
            _json = self._serialize.body(body, 'User')
        else:
            _json = None

        request = build_update_organization_user_me_request(
            organization_id=organization_id,
            content_type=content_type,
            json=_json,
            template_url=self.update_organization_user_me.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('UserDataResult', pipeline_response)

        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_organization_user_me.metadata = {'url': "/orgs/{organizationId}/me"}  # type: ignore


    @distributed_trace_async
    async def get_projects(
        self,
        organization_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.ProjectListDataResult, _models.ErrorResult]]:
        """Gets all Projects.

        Gets all Projects.

        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.ProjectListDataResult, _models.ErrorResult]]]

        
        request = build_get_projects_request(
            organization_id=organization_id,
            template_url=self.get_projects.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProjectListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_projects.metadata = {'url': "/orgs/{organizationId}/projects"}  # type: ignore


    @distributed_trace_async
    async def create_project(
        self,
        organization_id: str,
        body: Optional[_models.ProjectDefinition] = None,
        **kwargs: Any
    ) -> Optional[Union[_models.ProjectDataResult, _models.StatusResult, _models.ErrorResult]]:
        """Creates a new Project.

        Creates a new Project.

        :param organization_id:
        :type organization_id: str
        :param body:  Default value is None.
        :type body: ~teamcloud.models.ProjectDefinition
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectDataResult or StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectDataResult or ~teamcloud.models.StatusResult or
         ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.ProjectDataResult, _models.StatusResult, _models.ErrorResult]]]

        if body is not None:
            _json = self._serialize.body(body, 'ProjectDefinition')
        else:
            _json = None

        request = build_create_project_request(
            organization_id=organization_id,
            content_type=content_type,
            json=_json,
            template_url=self.create_project.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201, 202, 400, 401, 403, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 201:
            deserialized = self._deserialize('ProjectDataResult', pipeline_response)

        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_project.metadata = {'url': "/orgs/{organizationId}/projects"}  # type: ignore


    @distributed_trace_async
    async def get_project(
        self,
        project_id: str,
        organization_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.ProjectDataResult, _models.ErrorResult]]:
        """Gets a Project.

        Gets a Project.

        :param project_id:
        :type project_id: str
        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.ProjectDataResult, _models.ErrorResult]]]

        
        request = build_get_project_request(
            project_id=project_id,
            organization_id=organization_id,
            template_url=self.get_project.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProjectDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_project.metadata = {'url': "/orgs/{organizationId}/projects/{projectId}"}  # type: ignore


    @distributed_trace_async
    async def delete_project(
        self,
        project_id: str,
        organization_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.StatusResult, _models.ErrorResult]]:
        """Deletes a Project.

        Deletes a Project.

        :param project_id:
        :type project_id: str
        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.StatusResult, _models.ErrorResult]]]

        
        request = build_delete_project_request(
            project_id=project_id,
            organization_id=organization_id,
            template_url=self.delete_project.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    delete_project.metadata = {'url': "/orgs/{organizationId}/projects/{projectId}"}  # type: ignore


    @distributed_trace_async
    async def get_project_identities(
        self,
        organization_id: str,
        project_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.ProjectIdentityListDataResult, _models.ErrorResult]]:
        """Gets all Project Identities.

        Gets all Project Identities.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectIdentityListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectIdentityListDataResult or ~teamcloud.models.ErrorResult or
         None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.ProjectIdentityListDataResult, _models.ErrorResult]]]

        
        request = build_get_project_identities_request(
            organization_id=organization_id,
            project_id=project_id,
            template_url=self.get_project_identities.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProjectIdentityListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_project_identities.metadata = {'url': "/orgs/{organizationId}/projects/{projectId}/identities"}  # type: ignore


    @distributed_trace_async
    async def create_project_identity(
        self,
        organization_id: str,
        project_id: str,
        body: Optional[_models.ProjectIdentityDefinition] = None,
        **kwargs: Any
    ) -> Optional[Union[_models.ProjectIdentityDataResult, _models.ErrorResult]]:
        """Creates a new Project Identity.

        Creates a new Project Identity.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param body:  Default value is None.
        :type body: ~teamcloud.models.ProjectIdentityDefinition
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectIdentityDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectIdentityDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.ProjectIdentityDataResult, _models.ErrorResult]]]

        if body is not None:
            _json = self._serialize.body(body, 'ProjectIdentityDefinition')
        else:
            _json = None

        request = build_create_project_identity_request(
            organization_id=organization_id,
            project_id=project_id,
            content_type=content_type,
            json=_json,
            template_url=self.create_project_identity.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 401, 403, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 201:
            deserialized = self._deserialize('ProjectIdentityDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_project_identity.metadata = {'url': "/orgs/{organizationId}/projects/{projectId}/identities"}  # type: ignore


    @distributed_trace_async
    async def get_project_identity(
        self,
        project_identity_id: str,
        organization_id: str,
        project_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.ProjectIdentityDataResult, _models.ErrorResult]]:
        """Gets a Project Identity.

        Gets a Project Identity.

        :param project_identity_id:
        :type project_identity_id: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectIdentityDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectIdentityDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.ProjectIdentityDataResult, _models.ErrorResult]]]

        
        request = build_get_project_identity_request(
            project_identity_id=project_identity_id,
            organization_id=organization_id,
            project_id=project_id,
            template_url=self.get_project_identity.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProjectIdentityDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_project_identity.metadata = {'url': "/orgs/{organizationId}/projects/{projectId}/identities/{projectIdentityId}"}  # type: ignore


    @distributed_trace_async
    async def update_project_identity(
        self,
        project_identity_id: str,
        organization_id: str,
        project_id: str,
        body: Optional[_models.ProjectIdentity] = None,
        **kwargs: Any
    ) -> Optional[Union[_models.StatusResult, _models.ErrorResult]]:
        """Updates an existing Project Identity.

        Updates an existing Project Identity.

        :param project_identity_id:
        :type project_identity_id: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param body:  Default value is None.
        :type body: ~teamcloud.models.ProjectIdentity
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.StatusResult, _models.ErrorResult]]]

        if body is not None:
            _json = self._serialize.body(body, 'ProjectIdentity')
        else:
            _json = None

        request = build_update_project_identity_request(
            project_identity_id=project_identity_id,
            organization_id=organization_id,
            project_id=project_id,
            content_type=content_type,
            json=_json,
            template_url=self.update_project_identity.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_project_identity.metadata = {'url': "/orgs/{organizationId}/projects/{projectId}/identities/{projectIdentityId}"}  # type: ignore


    @distributed_trace_async
    async def delete_project_identity(
        self,
        project_identity_id: str,
        organization_id: str,
        project_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.ProjectIdentityDataResult, _models.ErrorResult]]:
        """Deletes a Project Identity.

        Deletes a Project Identity.

        :param project_identity_id:
        :type project_identity_id: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectIdentityDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectIdentityDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.ProjectIdentityDataResult, _models.ErrorResult]]]

        
        request = build_delete_project_identity_request(
            project_identity_id=project_identity_id,
            organization_id=organization_id,
            project_id=project_id,
            template_url=self.delete_project_identity.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [204, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 204:
            deserialized = self._deserialize('ProjectIdentityDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    delete_project_identity.metadata = {'url': "/orgs/{organizationId}/projects/{projectId}/identities/{projectIdentityId}"}  # type: ignore


    @distributed_trace_async
    async def get_project_tags(
        self,
        organization_id: str,
        project_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.StringDictionaryDataResult, _models.ErrorResult]]:
        """Gets all Tags for a Project.

        Gets all Tags for a Project.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StringDictionaryDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StringDictionaryDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.StringDictionaryDataResult, _models.ErrorResult]]]

        
        request = build_get_project_tags_request(
            organization_id=organization_id,
            project_id=project_id,
            template_url=self.get_project_tags.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('StringDictionaryDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_project_tags.metadata = {'url': "/orgs/{organizationId}/projects/{projectId}/tags"}  # type: ignore


    @distributed_trace_async
    async def create_project_tag(
        self,
        organization_id: str,
        project_id: str,
        body: Optional[Dict[str, str]] = None,
        **kwargs: Any
    ) -> Optional[Union[_models.StatusResult, _models.ErrorResult]]:
        """Creates a new Project Tag.

        Creates a new Project Tag.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param body:  Default value is None.
        :type body: dict[str, str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.StatusResult, _models.ErrorResult]]]

        if body is not None:
            _json = self._serialize.body(body, '{str}')
        else:
            _json = None

        request = build_create_project_tag_request(
            organization_id=organization_id,
            project_id=project_id,
            content_type=content_type,
            json=_json,
            template_url=self.create_project_tag.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 401, 403, 404, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_project_tag.metadata = {'url': "/orgs/{organizationId}/projects/{projectId}/tags"}  # type: ignore


    @distributed_trace_async
    async def update_project_tag(
        self,
        organization_id: str,
        project_id: str,
        body: Optional[Dict[str, str]] = None,
        **kwargs: Any
    ) -> Optional[Union[_models.StatusResult, _models.ErrorResult]]:
        """Updates an existing Project Tag.

        Updates an existing Project Tag.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param body:  Default value is None.
        :type body: dict[str, str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.StatusResult, _models.ErrorResult]]]

        if body is not None:
            _json = self._serialize.body(body, '{str}')
        else:
            _json = None

        request = build_update_project_tag_request(
            organization_id=organization_id,
            project_id=project_id,
            content_type=content_type,
            json=_json,
            template_url=self.update_project_tag.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_project_tag.metadata = {'url': "/orgs/{organizationId}/projects/{projectId}/tags"}  # type: ignore


    @distributed_trace_async
    async def get_project_tag_by_key(
        self,
        tag_key: str,
        organization_id: str,
        project_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.StringDictionaryDataResult, _models.ErrorResult]]:
        """Gets a Project Tag by Key.

        Gets a Project Tag by Key.

        :param tag_key:
        :type tag_key: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StringDictionaryDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StringDictionaryDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.StringDictionaryDataResult, _models.ErrorResult]]]

        
        request = build_get_project_tag_by_key_request(
            tag_key=tag_key,
            organization_id=organization_id,
            project_id=project_id,
            template_url=self.get_project_tag_by_key.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('StringDictionaryDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_project_tag_by_key.metadata = {'url': "/orgs/{organizationId}/projects/{projectId}/tags/{tagKey}"}  # type: ignore


    @distributed_trace_async
    async def delete_project_tag(
        self,
        tag_key: str,
        organization_id: str,
        project_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.StatusResult, _models.ErrorResult]]:
        """Deletes an existing Project Tag.

        Deletes an existing Project Tag.

        :param tag_key:
        :type tag_key: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.StatusResult, _models.ErrorResult]]]

        
        request = build_delete_project_tag_request(
            tag_key=tag_key,
            organization_id=organization_id,
            project_id=project_id,
            template_url=self.delete_project_tag.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    delete_project_tag.metadata = {'url': "/orgs/{organizationId}/projects/{projectId}/tags/{tagKey}"}  # type: ignore


    @distributed_trace_async
    async def get_project_templates(
        self,
        organization_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.ProjectTemplateListDataResult, _models.ErrorResult]]:
        """Gets all Project Templates.

        Gets all Project Templates.

        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectTemplateListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectTemplateListDataResult or ~teamcloud.models.ErrorResult or
         None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.ProjectTemplateListDataResult, _models.ErrorResult]]]

        
        request = build_get_project_templates_request(
            organization_id=organization_id,
            template_url=self.get_project_templates.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProjectTemplateListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_project_templates.metadata = {'url': "/orgs/{organizationId}/templates"}  # type: ignore


    @distributed_trace_async
    async def create_project_template(
        self,
        organization_id: str,
        body: Optional[_models.ProjectTemplateDefinition] = None,
        **kwargs: Any
    ) -> Optional[Union[_models.ProjectTemplateDataResult, _models.ErrorResult]]:
        """Creates a new Project Template.

        Creates a new Project Template.

        :param organization_id:
        :type organization_id: str
        :param body:  Default value is None.
        :type body: ~teamcloud.models.ProjectTemplateDefinition
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectTemplateDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectTemplateDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.ProjectTemplateDataResult, _models.ErrorResult]]]

        if body is not None:
            _json = self._serialize.body(body, 'ProjectTemplateDefinition')
        else:
            _json = None

        request = build_create_project_template_request(
            organization_id=organization_id,
            content_type=content_type,
            json=_json,
            template_url=self.create_project_template.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 401, 403, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 201:
            deserialized = self._deserialize('ProjectTemplateDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_project_template.metadata = {'url': "/orgs/{organizationId}/templates"}  # type: ignore


    @distributed_trace_async
    async def get_project_template(
        self,
        project_template_id: str,
        organization_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.ProjectTemplateDataResult, _models.ErrorResult]]:
        """Gets a Project Template.

        Gets a Project Template.

        :param project_template_id:
        :type project_template_id: str
        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectTemplateDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectTemplateDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.ProjectTemplateDataResult, _models.ErrorResult]]]

        
        request = build_get_project_template_request(
            project_template_id=project_template_id,
            organization_id=organization_id,
            template_url=self.get_project_template.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProjectTemplateDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_project_template.metadata = {'url': "/orgs/{organizationId}/templates/{projectTemplateId}"}  # type: ignore


    @distributed_trace_async
    async def update_project_template(
        self,
        project_template_id: str,
        organization_id: str,
        body: Optional[_models.ProjectTemplate] = None,
        **kwargs: Any
    ) -> Optional[Union[_models.ProjectTemplateDataResult, _models.ErrorResult]]:
        """Updates an existing Project Template.

        Updates an existing Project Template.

        :param project_template_id:
        :type project_template_id: str
        :param organization_id:
        :type organization_id: str
        :param body:  Default value is None.
        :type body: ~teamcloud.models.ProjectTemplate
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectTemplateDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectTemplateDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.ProjectTemplateDataResult, _models.ErrorResult]]]

        if body is not None:
            _json = self._serialize.body(body, 'ProjectTemplate')
        else:
            _json = None

        request = build_update_project_template_request(
            project_template_id=project_template_id,
            organization_id=organization_id,
            content_type=content_type,
            json=_json,
            template_url=self.update_project_template.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProjectTemplateDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_project_template.metadata = {'url': "/orgs/{organizationId}/templates/{projectTemplateId}"}  # type: ignore


    @distributed_trace_async
    async def delete_project_template(
        self,
        project_template_id: str,
        organization_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.ProjectTemplateDataResult, _models.ErrorResult]]:
        """Deletes a Project Template.

        Deletes a Project Template.

        :param project_template_id:
        :type project_template_id: str
        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectTemplateDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectTemplateDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.ProjectTemplateDataResult, _models.ErrorResult]]]

        
        request = build_delete_project_template_request(
            project_template_id=project_template_id,
            organization_id=organization_id,
            template_url=self.delete_project_template.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [204, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 204:
            deserialized = self._deserialize('ProjectTemplateDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    delete_project_template.metadata = {'url': "/orgs/{organizationId}/templates/{projectTemplateId}"}  # type: ignore


    @distributed_trace_async
    async def get_project_users(
        self,
        organization_id: str,
        project_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.UserListDataResult, _models.ErrorResult]]:
        """Gets all Users for a Project.

        Gets all Users for a Project.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UserListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.UserListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.UserListDataResult, _models.ErrorResult]]]

        
        request = build_get_project_users_request(
            organization_id=organization_id,
            project_id=project_id,
            template_url=self.get_project_users.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('UserListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_project_users.metadata = {'url': "/orgs/{organizationId}/projects/{projectId}/users"}  # type: ignore


    @distributed_trace_async
    async def create_project_user(
        self,
        organization_id: str,
        project_id: str,
        body: Optional[_models.UserDefinition] = None,
        **kwargs: Any
    ) -> Optional[Union[_models.UserDataResult, _models.StatusResult, _models.ErrorResult]]:
        """Creates a new Project User.

        Creates a new Project User.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param body:  Default value is None.
        :type body: ~teamcloud.models.UserDefinition
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UserDataResult or StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.UserDataResult or ~teamcloud.models.StatusResult or
         ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.UserDataResult, _models.StatusResult, _models.ErrorResult]]]

        if body is not None:
            _json = self._serialize.body(body, 'UserDefinition')
        else:
            _json = None

        request = build_create_project_user_request(
            organization_id=organization_id,
            project_id=project_id,
            content_type=content_type,
            json=_json,
            template_url=self.create_project_user.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201, 202, 400, 401, 403, 404, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 201:
            deserialized = self._deserialize('UserDataResult', pipeline_response)

        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_project_user.metadata = {'url': "/orgs/{organizationId}/projects/{projectId}/users"}  # type: ignore


    @distributed_trace_async
    async def get_project_user(
        self,
        user_id: str,
        organization_id: str,
        project_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.UserDataResult, _models.ErrorResult]]:
        """Gets a Project User by ID or email address.

        Gets a Project User by ID or email address.

        :param user_id:
        :type user_id: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UserDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.UserDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.UserDataResult, _models.ErrorResult]]]

        
        request = build_get_project_user_request(
            user_id=user_id,
            organization_id=organization_id,
            project_id=project_id,
            template_url=self.get_project_user.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('UserDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_project_user.metadata = {'url': "/orgs/{organizationId}/projects/{projectId}/users/{userId}"}  # type: ignore


    @distributed_trace_async
    async def update_project_user(
        self,
        user_id: str,
        organization_id: str,
        project_id: str,
        body: Optional[_models.User] = None,
        **kwargs: Any
    ) -> Optional[Union[_models.UserDataResult, _models.StatusResult, _models.ErrorResult]]:
        """Updates an existing Project User.

        Updates an existing Project User.

        :param user_id:
        :type user_id: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param body:  Default value is None.
        :type body: ~teamcloud.models.User
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UserDataResult or StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.UserDataResult or ~teamcloud.models.StatusResult or
         ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.UserDataResult, _models.StatusResult, _models.ErrorResult]]]

        if body is not None:
            _json = self._serialize.body(body, 'User')
        else:
            _json = None

        request = build_update_project_user_request(
            user_id=user_id,
            organization_id=organization_id,
            project_id=project_id,
            content_type=content_type,
            json=_json,
            template_url=self.update_project_user.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('UserDataResult', pipeline_response)

        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_project_user.metadata = {'url': "/orgs/{organizationId}/projects/{projectId}/users/{userId}"}  # type: ignore


    @distributed_trace_async
    async def delete_project_user(
        self,
        user_id: str,
        organization_id: str,
        project_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.StatusResult, _models.ErrorResult]]:
        """Deletes an existing Project User.

        Deletes an existing Project User.

        :param user_id:
        :type user_id: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.StatusResult, _models.ErrorResult]]]

        
        request = build_delete_project_user_request(
            user_id=user_id,
            organization_id=organization_id,
            project_id=project_id,
            template_url=self.delete_project_user.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    delete_project_user.metadata = {'url': "/orgs/{organizationId}/projects/{projectId}/users/{userId}"}  # type: ignore


    @distributed_trace_async
    async def get_project_user_me(
        self,
        organization_id: str,
        project_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.UserDataResult, _models.ErrorResult]]:
        """Gets a Project User for the calling user.

        Gets a Project User for the calling user.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UserDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.UserDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.UserDataResult, _models.ErrorResult]]]

        
        request = build_get_project_user_me_request(
            organization_id=organization_id,
            project_id=project_id,
            template_url=self.get_project_user_me.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('UserDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_project_user_me.metadata = {'url': "/orgs/{organizationId}/projects/{projectId}/users/me"}  # type: ignore


    @distributed_trace_async
    async def update_project_user_me(
        self,
        organization_id: str,
        project_id: str,
        body: Optional[_models.User] = None,
        **kwargs: Any
    ) -> Optional[Union[_models.UserDataResult, _models.StatusResult, _models.ErrorResult]]:
        """Updates an existing Project User.

        Updates an existing Project User.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param body:  Default value is None.
        :type body: ~teamcloud.models.User
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UserDataResult or StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.UserDataResult or ~teamcloud.models.StatusResult or
         ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.UserDataResult, _models.StatusResult, _models.ErrorResult]]]

        if body is not None:
            _json = self._serialize.body(body, 'User')
        else:
            _json = None

        request = build_update_project_user_me_request(
            organization_id=organization_id,
            project_id=project_id,
            content_type=content_type,
            json=_json,
            template_url=self.update_project_user_me.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('UserDataResult', pipeline_response)

        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_project_user_me.metadata = {'url': "/orgs/{organizationId}/projects/{projectId}/users/me"}  # type: ignore


    @distributed_trace_async
    async def get_info(
        self,
        **kwargs: Any
    ) -> _models.TeamCloudInformationDataResult:
        """Gets information about this TeamCloud deployment.

        Gets information about this TeamCloud deployment.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: TeamCloudInformationDataResult, or the result of cls(response)
        :rtype: ~teamcloud.models.TeamCloudInformationDataResult
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[_models.TeamCloudInformationDataResult]

        
        request = build_get_info_request(
            template_url=self.get_info.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('TeamCloudInformationDataResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_info.metadata = {'url': "/"}  # type: ignore


    @distributed_trace_async
    async def get_schedules(
        self,
        organization_id: str,
        project_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.ScheduleListDataResult, _models.ErrorResult]]:
        """Gets all Schedule.

        Gets all Schedule.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ScheduleListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ScheduleListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.ScheduleListDataResult, _models.ErrorResult]]]

        
        request = build_get_schedules_request(
            organization_id=organization_id,
            project_id=project_id,
            template_url=self.get_schedules.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ScheduleListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_schedules.metadata = {'url': "/orgs/{organizationId}/projects/{projectId}/schedules"}  # type: ignore


    @distributed_trace_async
    async def create_schedule(
        self,
        organization_id: str,
        project_id: str,
        body: Optional[_models.ScheduleDefinition] = None,
        **kwargs: Any
    ) -> Optional[Union[_models.ScheduleDataResult, _models.ErrorResult]]:
        """Creates a new Project Schedule.

        Creates a new Project Schedule.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param body:  Default value is None.
        :type body: ~teamcloud.models.ScheduleDefinition
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ScheduleDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ScheduleDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.ScheduleDataResult, _models.ErrorResult]]]

        if body is not None:
            _json = self._serialize.body(body, 'ScheduleDefinition')
        else:
            _json = None

        request = build_create_schedule_request(
            organization_id=organization_id,
            project_id=project_id,
            content_type=content_type,
            json=_json,
            template_url=self.create_schedule.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 401, 403, 404, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 201:
            deserialized = self._deserialize('ScheduleDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_schedule.metadata = {'url': "/orgs/{organizationId}/projects/{projectId}/schedules"}  # type: ignore


    @distributed_trace_async
    async def get_schedule(
        self,
        schedule_id: str,
        organization_id: str,
        project_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.ScheduleDataResult, _models.ErrorResult]]:
        """Gets the Schedule.

        Gets the Schedule.

        :param schedule_id:
        :type schedule_id: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ScheduleDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ScheduleDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.ScheduleDataResult, _models.ErrorResult]]]

        
        request = build_get_schedule_request(
            schedule_id=schedule_id,
            organization_id=organization_id,
            project_id=project_id,
            template_url=self.get_schedule.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ScheduleDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_schedule.metadata = {'url': "/orgs/{organizationId}/projects/{projectId}/schedules/{scheduleId}"}  # type: ignore


    @distributed_trace_async
    async def update_schedule(
        self,
        schedule_id: str,
        organization_id: str,
        project_id: str,
        body: Optional[_models.Schedule] = None,
        **kwargs: Any
    ) -> Optional[Union[_models.ScheduleDataResult, _models.ErrorResult]]:
        """Updates a Project Schedule.

        Updates a Project Schedule.

        :param schedule_id:
        :type schedule_id: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param body:  Default value is None.
        :type body: ~teamcloud.models.Schedule
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ScheduleDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ScheduleDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = case_insensitive_dict(kwargs.pop("headers", {}) or {})
        _params = kwargs.pop("params", {}) or {}

        content_type = kwargs.pop('content_type', _headers.pop('Content-Type', "application/json"))  # type: Optional[str]
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.ScheduleDataResult, _models.ErrorResult]]]

        if body is not None:
            _json = self._serialize.body(body, 'Schedule')
        else:
            _json = None

        request = build_update_schedule_request(
            schedule_id=schedule_id,
            organization_id=organization_id,
            project_id=project_id,
            content_type=content_type,
            json=_json,
            template_url=self.update_schedule.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ScheduleDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_schedule.metadata = {'url': "/orgs/{organizationId}/projects/{projectId}/schedules/{scheduleId}"}  # type: ignore


    @distributed_trace_async
    async def run_schedule(
        self,
        schedule_id: str,
        organization_id: str,
        project_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.ScheduleDataResult, _models.ErrorResult]]:
        """Runs a Project Schedule.

        Runs a Project Schedule.

        :param schedule_id:
        :type schedule_id: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ScheduleDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ScheduleDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.ScheduleDataResult, _models.ErrorResult]]]

        
        request = build_run_schedule_request(
            schedule_id=schedule_id,
            organization_id=organization_id,
            project_id=project_id,
            template_url=self.run_schedule.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ScheduleDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    run_schedule.metadata = {'url': "/orgs/{organizationId}/projects/{projectId}/schedules/{scheduleId}/run"}  # type: ignore


    @distributed_trace_async
    async def get_status(
        self,
        tracking_id: str,
        organization_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.StatusResult, _models.ErrorResult]]:
        """Gets the status of a long-running operation.

        Gets the status of a long-running operation.

        :param tracking_id:
        :type tracking_id: str
        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.StatusResult, _models.ErrorResult]]]

        
        request = build_get_status_request(
            tracking_id=tracking_id,
            organization_id=organization_id,
            template_url=self.get_status.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 302, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 302:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_status.metadata = {'url': "/orgs/{organizationId}/status/{trackingId}"}  # type: ignore


    @distributed_trace_async
    async def get_project_status(
        self,
        project_id: str,
        tracking_id: str,
        organization_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.StatusResult, _models.ErrorResult]]:
        """Gets the status of a long-running operation.

        Gets the status of a long-running operation.

        :param project_id:
        :type project_id: str
        :param tracking_id:
        :type tracking_id: str
        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.StatusResult, _models.ErrorResult]]]

        
        request = build_get_project_status_request(
            project_id=project_id,
            tracking_id=tracking_id,
            organization_id=organization_id,
            template_url=self.get_project_status.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 302, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 302:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_project_status.metadata = {'url': "/orgs/{organizationId}/projects/{projectId}/status/{trackingId}"}  # type: ignore


    @distributed_trace_async
    async def get_user_projects(
        self,
        organization_id: str,
        user_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.ProjectListDataResult, _models.ErrorResult]]:
        """Gets all Projects for a User.

        Gets all Projects for a User.

        :param organization_id:
        :type organization_id: str
        :param user_id:
        :type user_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.ProjectListDataResult, _models.ErrorResult]]]

        
        request = build_get_user_projects_request(
            organization_id=organization_id,
            user_id=user_id,
            template_url=self.get_user_projects.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProjectListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_user_projects.metadata = {'url': "/orgs/{organizationId}/users/{userId}/projects"}  # type: ignore


    @distributed_trace_async
    async def get_user_projects_me(
        self,
        organization_id: str,
        **kwargs: Any
    ) -> Optional[Union[_models.ProjectListDataResult, _models.ErrorResult]]:
        """Gets all Projects for a User.

        Gets all Projects for a User.

        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}) or {})

        _headers = kwargs.pop("headers", {}) or {}
        _params = kwargs.pop("params", {}) or {}

        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union[_models.ProjectListDataResult, _models.ErrorResult]]]

        
        request = build_get_user_projects_me_request(
            organization_id=organization_id,
            template_url=self.get_user_projects_me.metadata['url'],
            headers=_headers,
            params=_params,
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)  # type: ignore

        pipeline_response = await self._client._pipeline.run(  # type: ignore # pylint: disable=protected-access
            request,
            stream=False,
            **kwargs
        )
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProjectListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_user_projects_me.metadata = {'url': "/orgs/{organizationId}/me/projects"}  # type: ignore

