# coding=utf-8
# --------------------------------------------------------------------------
# Copyright (c) Microsoft Corporation. All rights reserved.
# Licensed under the MIT License. See License.txt in the project root for license information.
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is regenerated.
# --------------------------------------------------------------------------
import functools
from typing import TYPE_CHECKING
import warnings

from azure.core.exceptions import ClientAuthenticationError, HttpResponseError, ResourceExistsError, ResourceNotFoundError, map_error
from azure.core.pipeline import PipelineResponse
from azure.core.pipeline.transport import HttpResponse
from azure.core.rest import HttpRequest
from azure.core.tracing.decorator import distributed_trace
from msrest import Serializer

from .. import models as _models
from .._vendor import _convert_request, _format_url_section

if TYPE_CHECKING:
    # pylint: disable=unused-import,ungrouped-imports
    from typing import Any, Callable, Dict, Generic, List, Optional, TypeVar, Union
    T = TypeVar('T')
    ClsType = Optional[Callable[[PipelineResponse[HttpRequest, HttpResponse], T, Dict[str, Any]], Any]]

_SERIALIZER = Serializer()
_SERIALIZER.client_side_validation = False
# fmt: off

def build_get_adapters_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/adapters')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_components_request(
    organization_id,  # type: str
    project_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    deleted = kwargs.pop('deleted', False)  # type: Optional[bool]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/projects/{projectId}/components')
    path_format_arguments = {
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
        "projectId": _SERIALIZER.url("project_id", project_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if deleted is not None:
        query_parameters['deleted'] = _SERIALIZER.query("deleted", deleted, 'bool')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_create_component_request(
    organization_id,  # type: str
    project_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/projects/{projectId}/components')
    path_format_arguments = {
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
        "projectId": _SERIALIZER.url("project_id", project_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_component_request(
    component_id,  # type: str
    organization_id,  # type: str
    project_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/projects/{projectId}/components/{componentId}')
    path_format_arguments = {
        "componentId": _SERIALIZER.url("component_id", component_id, 'str'),
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
        "projectId": _SERIALIZER.url("project_id", project_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_delete_component_request(
    component_id,  # type: str
    organization_id,  # type: str
    project_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/projects/{projectId}/components/{componentId}')
    path_format_arguments = {
        "componentId": _SERIALIZER.url("component_id", component_id, 'str'),
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
        "projectId": _SERIALIZER.url("project_id", project_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_component_tasks_request(
    organization_id,  # type: str
    project_id,  # type: str
    component_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/projects/{projectId}/components/{componentId}/tasks')
    path_format_arguments = {
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
        "projectId": _SERIALIZER.url("project_id", project_id, 'str'),
        "componentId": _SERIALIZER.url("component_id", component_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_create_component_task_request(
    organization_id,  # type: str
    project_id,  # type: str
    component_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/projects/{projectId}/components/{componentId}/tasks')
    path_format_arguments = {
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
        "projectId": _SERIALIZER.url("project_id", project_id, 'str'),
        "componentId": _SERIALIZER.url("component_id", component_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_component_task_request(
    task_id,  # type: str
    organization_id,  # type: str
    project_id,  # type: str
    component_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/projects/{projectId}/components/{componentId}/tasks/{taskId}')
    path_format_arguments = {
        "taskId": _SERIALIZER.url("task_id", task_id, 'str'),
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
        "projectId": _SERIALIZER.url("project_id", project_id, 'str'),
        "componentId": _SERIALIZER.url("component_id", component_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_cancel_component_task_request(
    organization_id,  # type: str
    project_id,  # type: str
    component_id,  # type: str
    task_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/projects/{projectId}/components/{componentId}/tasks/{taskId}/cancel')
    path_format_arguments = {
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
        "projectId": _SERIALIZER.url("project_id", project_id, 'str'),
        "componentId": _SERIALIZER.url("component_id", component_id, 'str'),
        "taskId": _SERIALIZER.url("task_id", task_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_re_run_component_task_request(
    organization_id,  # type: str
    project_id,  # type: str
    component_id,  # type: str
    task_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/projects/{projectId}/components/{componentId}/tasks/{taskId}/rerun')
    path_format_arguments = {
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
        "projectId": _SERIALIZER.url("project_id", project_id, 'str'),
        "componentId": _SERIALIZER.url("component_id", component_id, 'str'),
        "taskId": _SERIALIZER.url("task_id", task_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_component_templates_request(
    organization_id,  # type: str
    project_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/projects/{projectId}/templates')
    path_format_arguments = {
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
        "projectId": _SERIALIZER.url("project_id", project_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_component_template_request(
    id,  # type: str
    organization_id,  # type: str
    project_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/projects/{projectId}/templates/{id}')
    path_format_arguments = {
        "id": _SERIALIZER.url("id", id, 'str'),
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
        "projectId": _SERIALIZER.url("project_id", project_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_deployment_scopes_request(
    organization_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/scopes')
    path_format_arguments = {
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_create_deployment_scope_request(
    organization_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/scopes')
    path_format_arguments = {
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_deployment_scope_request(
    organization_id,  # type: str
    deployment_scope_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/scopes/{deploymentScopeId}')
    path_format_arguments = {
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
        "deploymentScopeId": _SERIALIZER.url("deployment_scope_id", deployment_scope_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_update_deployment_scope_request(
    organization_id,  # type: str
    deployment_scope_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/scopes/{deploymentScopeId}')
    path_format_arguments = {
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
        "deploymentScopeId": _SERIALIZER.url("deployment_scope_id", deployment_scope_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_delete_deployment_scope_request(
    organization_id,  # type: str
    deployment_scope_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/scopes/{deploymentScopeId}')
    path_format_arguments = {
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
        "deploymentScopeId": _SERIALIZER.url("deployment_scope_id", deployment_scope_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_initialize_authorization_request(
    organization_id,  # type: str
    deployment_scope_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/scopes/{deploymentScopeId}/authorize/initialize')
    path_format_arguments = {
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
        "deploymentScopeId": _SERIALIZER.url("deployment_scope_id", deployment_scope_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_negotiate_signal_r_request(
    organization_id,  # type: str
    project_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/projects/{projectId}/negotiate')
    path_format_arguments = {
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
        "projectId": _SERIALIZER.url("project_id", project_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    return HttpRequest(
        method="POST",
        url=url,
        **kwargs
    )


def build_get_audit_entries_request(
    organization_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    time_range = kwargs.pop('time_range', None)  # type: Optional[str]
    commands = kwargs.pop('commands', None)  # type: Optional[List[str]]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/audit')
    path_format_arguments = {
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if time_range is not None:
        query_parameters['timeRange'] = _SERIALIZER.query("time_range", time_range, 'str')
    if commands is not None:
        query_parameters['commands'] = _SERIALIZER.query("commands", commands, '[str]')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_get_audit_entry_request(
    command_id,  # type: str
    organization_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    expand = kwargs.pop('expand', False)  # type: Optional[bool]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/audit/{commandId}')
    path_format_arguments = {
        "commandId": _SERIALIZER.url("command_id", command_id, 'str'),
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct parameters
    query_parameters = kwargs.pop("params", {})  # type: Dict[str, Any]
    if expand is not None:
        query_parameters['expand'] = _SERIALIZER.query("expand", expand, 'bool')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        params=query_parameters,
        headers=header_parameters,
        **kwargs
    )


def build_get_audit_commands_request(
    organization_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/audit/commands')
    path_format_arguments = {
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_organizations_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_create_organization_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_organization_request(
    organization_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}')
    path_format_arguments = {
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_delete_organization_request(
    organization_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}')
    path_format_arguments = {
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_organization_users_request(
    organization_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/users')
    path_format_arguments = {
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_create_organization_user_request(
    organization_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/users')
    path_format_arguments = {
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_organization_user_request(
    user_id,  # type: str
    organization_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/users/{userId}')
    path_format_arguments = {
        "userId": _SERIALIZER.url("user_id", user_id, 'str'),
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_update_organization_user_request(
    user_id,  # type: str
    organization_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/users/{userId}')
    path_format_arguments = {
        "userId": _SERIALIZER.url("user_id", user_id, 'str'),
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_delete_organization_user_request(
    user_id,  # type: str
    organization_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/users/{userId}')
    path_format_arguments = {
        "userId": _SERIALIZER.url("user_id", user_id, 'str'),
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_organization_user_me_request(
    organization_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/me')
    path_format_arguments = {
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_update_organization_user_me_request(
    organization_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/me')
    path_format_arguments = {
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_projects_request(
    organization_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/projects')
    path_format_arguments = {
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_create_project_request(
    organization_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/projects')
    path_format_arguments = {
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_project_request(
    project_id,  # type: str
    organization_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/projects/{projectId}')
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, 'str'),
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_delete_project_request(
    project_id,  # type: str
    organization_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/projects/{projectId}')
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, 'str'),
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_project_identities_request(
    organization_id,  # type: str
    project_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/projects/{projectId}/identities')
    path_format_arguments = {
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
        "projectId": _SERIALIZER.url("project_id", project_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_create_project_identity_request(
    organization_id,  # type: str
    project_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/projects/{projectId}/identities')
    path_format_arguments = {
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
        "projectId": _SERIALIZER.url("project_id", project_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_project_identity_request(
    project_identity_id,  # type: str
    organization_id,  # type: str
    project_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/projects/{projectId}/identities/{projectIdentityId}')
    path_format_arguments = {
        "projectIdentityId": _SERIALIZER.url("project_identity_id", project_identity_id, 'str'),
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
        "projectId": _SERIALIZER.url("project_id", project_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_update_project_identity_request(
    project_identity_id,  # type: str
    organization_id,  # type: str
    project_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/projects/{projectId}/identities/{projectIdentityId}')
    path_format_arguments = {
        "projectIdentityId": _SERIALIZER.url("project_identity_id", project_identity_id, 'str'),
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
        "projectId": _SERIALIZER.url("project_id", project_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_delete_project_identity_request(
    project_identity_id,  # type: str
    organization_id,  # type: str
    project_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/projects/{projectId}/identities/{projectIdentityId}')
    path_format_arguments = {
        "projectIdentityId": _SERIALIZER.url("project_identity_id", project_identity_id, 'str'),
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
        "projectId": _SERIALIZER.url("project_id", project_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_project_tags_request(
    organization_id,  # type: str
    project_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/projects/{projectId}/tags')
    path_format_arguments = {
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
        "projectId": _SERIALIZER.url("project_id", project_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_create_project_tag_request(
    organization_id,  # type: str
    project_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/projects/{projectId}/tags')
    path_format_arguments = {
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
        "projectId": _SERIALIZER.url("project_id", project_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_update_project_tag_request(
    organization_id,  # type: str
    project_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/projects/{projectId}/tags')
    path_format_arguments = {
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
        "projectId": _SERIALIZER.url("project_id", project_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_project_tag_by_key_request(
    tag_key,  # type: str
    organization_id,  # type: str
    project_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/projects/{projectId}/tags/{tagKey}')
    path_format_arguments = {
        "tagKey": _SERIALIZER.url("tag_key", tag_key, 'str'),
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
        "projectId": _SERIALIZER.url("project_id", project_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_delete_project_tag_request(
    tag_key,  # type: str
    organization_id,  # type: str
    project_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/projects/{projectId}/tags/{tagKey}')
    path_format_arguments = {
        "tagKey": _SERIALIZER.url("tag_key", tag_key, 'str'),
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
        "projectId": _SERIALIZER.url("project_id", project_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_project_templates_request(
    organization_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/templates')
    path_format_arguments = {
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_create_project_template_request(
    organization_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/templates')
    path_format_arguments = {
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_project_template_request(
    project_template_id,  # type: str
    organization_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/templates/{projectTemplateId}')
    path_format_arguments = {
        "projectTemplateId": _SERIALIZER.url("project_template_id", project_template_id, 'str'),
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_update_project_template_request(
    project_template_id,  # type: str
    organization_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/templates/{projectTemplateId}')
    path_format_arguments = {
        "projectTemplateId": _SERIALIZER.url("project_template_id", project_template_id, 'str'),
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_delete_project_template_request(
    project_template_id,  # type: str
    organization_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/templates/{projectTemplateId}')
    path_format_arguments = {
        "projectTemplateId": _SERIALIZER.url("project_template_id", project_template_id, 'str'),
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_project_users_request(
    organization_id,  # type: str
    project_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/projects/{projectId}/users')
    path_format_arguments = {
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
        "projectId": _SERIALIZER.url("project_id", project_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_create_project_user_request(
    organization_id,  # type: str
    project_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/projects/{projectId}/users')
    path_format_arguments = {
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
        "projectId": _SERIALIZER.url("project_id", project_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_project_user_request(
    user_id,  # type: str
    organization_id,  # type: str
    project_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/projects/{projectId}/users/{userId}')
    path_format_arguments = {
        "userId": _SERIALIZER.url("user_id", user_id, 'str'),
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
        "projectId": _SERIALIZER.url("project_id", project_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_update_project_user_request(
    user_id,  # type: str
    organization_id,  # type: str
    project_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/projects/{projectId}/users/{userId}')
    path_format_arguments = {
        "userId": _SERIALIZER.url("user_id", user_id, 'str'),
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
        "projectId": _SERIALIZER.url("project_id", project_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_delete_project_user_request(
    user_id,  # type: str
    organization_id,  # type: str
    project_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/projects/{projectId}/users/{userId}')
    path_format_arguments = {
        "userId": _SERIALIZER.url("user_id", user_id, 'str'),
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
        "projectId": _SERIALIZER.url("project_id", project_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="DELETE",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_project_user_me_request(
    organization_id,  # type: str
    project_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/projects/{projectId}/users/me')
    path_format_arguments = {
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
        "projectId": _SERIALIZER.url("project_id", project_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_update_project_user_me_request(
    organization_id,  # type: str
    project_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/projects/{projectId}/users/me')
    path_format_arguments = {
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
        "projectId": _SERIALIZER.url("project_id", project_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_info_request(
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/')

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_schedules_request(
    organization_id,  # type: str
    project_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/projects/{projectId}/schedules')
    path_format_arguments = {
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
        "projectId": _SERIALIZER.url("project_id", project_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_create_schedule_request(
    organization_id,  # type: str
    project_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/projects/{projectId}/schedules')
    path_format_arguments = {
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
        "projectId": _SERIALIZER.url("project_id", project_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_schedule_request(
    schedule_id,  # type: str
    organization_id,  # type: str
    project_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/projects/{projectId}/schedules/{scheduleId}')
    path_format_arguments = {
        "scheduleId": _SERIALIZER.url("schedule_id", schedule_id, 'str'),
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
        "projectId": _SERIALIZER.url("project_id", project_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_update_schedule_request(
    schedule_id,  # type: str
    organization_id,  # type: str
    project_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    content_type = kwargs.pop('content_type', None)  # type: Optional[str]

    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/projects/{projectId}/schedules/{scheduleId}')
    path_format_arguments = {
        "scheduleId": _SERIALIZER.url("schedule_id", schedule_id, 'str'),
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
        "projectId": _SERIALIZER.url("project_id", project_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    if content_type is not None:
        header_parameters['Content-Type'] = _SERIALIZER.header("content_type", content_type, 'str')
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="PUT",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_run_schedule_request(
    schedule_id,  # type: str
    organization_id,  # type: str
    project_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/projects/{projectId}/schedules/{scheduleId}/run')
    path_format_arguments = {
        "scheduleId": _SERIALIZER.url("schedule_id", schedule_id, 'str'),
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
        "projectId": _SERIALIZER.url("project_id", project_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="POST",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_status_request(
    tracking_id,  # type: str
    organization_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/status/{trackingId}')
    path_format_arguments = {
        "trackingId": _SERIALIZER.url("tracking_id", tracking_id, 'str'),
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_project_status_request(
    project_id,  # type: str
    tracking_id,  # type: str
    organization_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/projects/{projectId}/status/{trackingId}')
    path_format_arguments = {
        "projectId": _SERIALIZER.url("project_id", project_id, 'str'),
        "trackingId": _SERIALIZER.url("tracking_id", tracking_id, 'str'),
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_user_projects_request(
    organization_id,  # type: str
    user_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/users/{userId}/projects')
    path_format_arguments = {
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
        "userId": _SERIALIZER.url("user_id", user_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )


def build_get_user_projects_me_request(
    organization_id,  # type: str
    **kwargs  # type: Any
):
    # type: (...) -> HttpRequest
    accept = "application/json"
    # Construct URL
    url = kwargs.pop("template_url", '/orgs/{organizationId}/me/projects')
    path_format_arguments = {
        "organizationId": _SERIALIZER.url("organization_id", organization_id, 'str'),
    }

    url = _format_url_section(url, **path_format_arguments)

    # Construct headers
    header_parameters = kwargs.pop("headers", {})  # type: Dict[str, Any]
    header_parameters['Accept'] = _SERIALIZER.header("accept", accept, 'str')

    return HttpRequest(
        method="GET",
        url=url,
        headers=header_parameters,
        **kwargs
    )

# fmt: on
class TeamCloudClientOperationsMixin(object):

    @distributed_trace
    def get_adapters(
        self,
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.AdapterInformationListDataResult", "_models.ErrorResult"]]
        """Gets all Adapters.

        Gets all Adapters.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: AdapterInformationListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.AdapterInformationListDataResult or ~teamcloud.models.ErrorResult or
         None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.AdapterInformationListDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_adapters_request(
            template_url=self.get_adapters.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('AdapterInformationListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_adapters.metadata = {'url': '/adapters'}  # type: ignore


    @distributed_trace
    def get_components(
        self,
        organization_id,  # type: str
        project_id,  # type: str
        deleted=False,  # type: Optional[bool]
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.ComponentListDataResult", "_models.ErrorResult"]]
        """Gets all Components for a Project.

        Gets all Components for a Project.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param deleted:
        :type deleted: bool
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ComponentListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ComponentListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ComponentListDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_components_request(
            organization_id=organization_id,
            project_id=project_id,
            deleted=deleted,
            template_url=self.get_components.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ComponentListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_components.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/components'}  # type: ignore


    @distributed_trace
    def create_component(
        self,
        organization_id,  # type: str
        project_id,  # type: str
        body=None,  # type: Optional["_models.ComponentDefinition"]
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.ComponentDataResult", "_models.StatusResult", "_models.ErrorResult"]]
        """Creates a new Project Component.

        Creates a new Project Component.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param body:
        :type body: ~teamcloud.models.ComponentDefinition
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ComponentDataResult or StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ComponentDataResult or ~teamcloud.models.StatusResult or
         ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ComponentDataResult", "_models.StatusResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        if body is not None:
            _json = self._serialize.body(body, 'ComponentDefinition')
        else:
            _json = None

        request = build_create_component_request(
            organization_id=organization_id,
            project_id=project_id,
            content_type=content_type,
            json=_json,
            template_url=self.create_component.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201, 202, 400, 401, 403, 404, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 201:
            deserialized = self._deserialize('ComponentDataResult', pipeline_response)

        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_component.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/components'}  # type: ignore


    @distributed_trace
    def get_component(
        self,
        component_id,  # type: str
        organization_id,  # type: str
        project_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.ComponentDataResult", "_models.ErrorResult"]]
        """Gets a Project Component.

        Gets a Project Component.

        :param component_id:
        :type component_id: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ComponentDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ComponentDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ComponentDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_component_request(
            component_id=component_id,
            organization_id=organization_id,
            project_id=project_id,
            template_url=self.get_component.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ComponentDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_component.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/components/{componentId}'}  # type: ignore


    @distributed_trace
    def delete_component(
        self,
        component_id,  # type: str
        organization_id,  # type: str
        project_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.StatusResult", "_models.ComponentDataResult", "_models.ErrorResult"]]
        """Deletes an existing Project Component.

        Deletes an existing Project Component.

        :param component_id:
        :type component_id: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ComponentDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ComponentDataResult or
         ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.StatusResult", "_models.ComponentDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_delete_component_request(
            component_id=component_id,
            organization_id=organization_id,
            project_id=project_id,
            template_url=self.delete_component.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 204, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 204:
            deserialized = self._deserialize('ComponentDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    delete_component.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/components/{componentId}'}  # type: ignore


    @distributed_trace
    def get_component_tasks(
        self,
        organization_id,  # type: str
        project_id,  # type: str
        component_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.ComponentTaskListDataResult", "_models.ErrorResult"]]
        """Gets all Component Tasks.

        Gets all Component Tasks.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param component_id:
        :type component_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ComponentTaskListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ComponentTaskListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ComponentTaskListDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_component_tasks_request(
            organization_id=organization_id,
            project_id=project_id,
            component_id=component_id,
            template_url=self.get_component_tasks.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ComponentTaskListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_component_tasks.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/components/{componentId}/tasks'}  # type: ignore


    @distributed_trace
    def create_component_task(
        self,
        organization_id,  # type: str
        project_id,  # type: str
        component_id,  # type: str
        body=None,  # type: Optional["_models.ComponentTaskDefinition"]
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.ComponentTaskDataResult", "_models.StatusResult", "_models.ErrorResult"]]
        """Creates a new Project Component Task.

        Creates a new Project Component Task.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param component_id:
        :type component_id: str
        :param body:
        :type body: ~teamcloud.models.ComponentTaskDefinition
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ComponentTaskDataResult or StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ComponentTaskDataResult or ~teamcloud.models.StatusResult or
         ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ComponentTaskDataResult", "_models.StatusResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        if body is not None:
            _json = self._serialize.body(body, 'ComponentTaskDefinition')
        else:
            _json = None

        request = build_create_component_task_request(
            organization_id=organization_id,
            project_id=project_id,
            component_id=component_id,
            content_type=content_type,
            json=_json,
            template_url=self.create_component_task.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201, 202, 400, 401, 403, 404, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 201:
            deserialized = self._deserialize('ComponentTaskDataResult', pipeline_response)

        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_component_task.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/components/{componentId}/tasks'}  # type: ignore


    @distributed_trace
    def get_component_task(
        self,
        task_id,  # type: str
        organization_id,  # type: str
        project_id,  # type: str
        component_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.ComponentTaskDataResult", "_models.ErrorResult"]]
        """Gets the Component Task.

        Gets the Component Task.

        :param task_id:
        :type task_id: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param component_id:
        :type component_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ComponentTaskDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ComponentTaskDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ComponentTaskDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_component_task_request(
            task_id=task_id,
            organization_id=organization_id,
            project_id=project_id,
            component_id=component_id,
            template_url=self.get_component_task.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ComponentTaskDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_component_task.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/components/{componentId}/tasks/{taskId}'}  # type: ignore


    @distributed_trace
    def cancel_component_task(
        self,
        organization_id,  # type: str
        project_id,  # type: str
        component_id,  # type: str
        task_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.ComponentTaskDataResult", "_models.StatusResult", "_models.ErrorResult"]]
        """Rerun a Project Component Task.

        Rerun a Project Component Task.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param component_id:
        :type component_id: str
        :param task_id:
        :type task_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ComponentTaskDataResult or StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ComponentTaskDataResult or ~teamcloud.models.StatusResult or
         ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ComponentTaskDataResult", "_models.StatusResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_cancel_component_task_request(
            organization_id=organization_id,
            project_id=project_id,
            component_id=component_id,
            task_id=task_id,
            template_url=self.cancel_component_task.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ComponentTaskDataResult', pipeline_response)

        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    cancel_component_task.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/components/{componentId}/tasks/{taskId}/cancel'}  # type: ignore


    @distributed_trace
    def re_run_component_task(
        self,
        organization_id,  # type: str
        project_id,  # type: str
        component_id,  # type: str
        task_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.ComponentTaskDataResult", "_models.StatusResult", "_models.ErrorResult"]]
        """Cancel an active Project Component Task.

        Cancel an active Project Component Task.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param component_id:
        :type component_id: str
        :param task_id:
        :type task_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ComponentTaskDataResult or StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ComponentTaskDataResult or ~teamcloud.models.StatusResult or
         ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ComponentTaskDataResult", "_models.StatusResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_re_run_component_task_request(
            organization_id=organization_id,
            project_id=project_id,
            component_id=component_id,
            task_id=task_id,
            template_url=self.re_run_component_task.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201, 202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 201:
            deserialized = self._deserialize('ComponentTaskDataResult', pipeline_response)

        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    re_run_component_task.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/components/{componentId}/tasks/{taskId}/rerun'}  # type: ignore


    @distributed_trace
    def get_component_templates(
        self,
        organization_id,  # type: str
        project_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.ComponentTemplateListDataResult", "_models.ErrorResult"]]
        """Gets all Component Templates for a Project.

        Gets all Component Templates for a Project.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ComponentTemplateListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ComponentTemplateListDataResult or ~teamcloud.models.ErrorResult or
         None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ComponentTemplateListDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_component_templates_request(
            organization_id=organization_id,
            project_id=project_id,
            template_url=self.get_component_templates.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ComponentTemplateListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_component_templates.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/templates'}  # type: ignore


    @distributed_trace
    def get_component_template(
        self,
        id,  # type: str
        organization_id,  # type: str
        project_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.ComponentTemplateDataResult", "_models.ErrorResult"]]
        """Gets the Component Template.

        Gets the Component Template.

        :param id:
        :type id: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ComponentTemplateDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ComponentTemplateDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ComponentTemplateDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_component_template_request(
            id=id,
            organization_id=organization_id,
            project_id=project_id,
            template_url=self.get_component_template.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ComponentTemplateDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_component_template.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/templates/{id}'}  # type: ignore


    @distributed_trace
    def get_deployment_scopes(
        self,
        organization_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.DeploymentScopeListDataResult", "_models.ErrorResult"]]
        """Gets all Deployment Scopes.

        Gets all Deployment Scopes.

        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: DeploymentScopeListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.DeploymentScopeListDataResult or ~teamcloud.models.ErrorResult or
         None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.DeploymentScopeListDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_deployment_scopes_request(
            organization_id=organization_id,
            template_url=self.get_deployment_scopes.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('DeploymentScopeListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_deployment_scopes.metadata = {'url': '/orgs/{organizationId}/scopes'}  # type: ignore


    @distributed_trace
    def create_deployment_scope(
        self,
        organization_id,  # type: str
        body=None,  # type: Optional["_models.DeploymentScopeDefinition"]
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.DeploymentScopeDataResult", "_models.ErrorResult"]]
        """Creates a new Deployment Scope.

        Creates a new Deployment Scope.

        :param organization_id:
        :type organization_id: str
        :param body:
        :type body: ~teamcloud.models.DeploymentScopeDefinition
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: DeploymentScopeDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.DeploymentScopeDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.DeploymentScopeDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        if body is not None:
            _json = self._serialize.body(body, 'DeploymentScopeDefinition')
        else:
            _json = None

        request = build_create_deployment_scope_request(
            organization_id=organization_id,
            content_type=content_type,
            json=_json,
            template_url=self.create_deployment_scope.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 401, 403, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 201:
            deserialized = self._deserialize('DeploymentScopeDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_deployment_scope.metadata = {'url': '/orgs/{organizationId}/scopes'}  # type: ignore


    @distributed_trace
    def get_deployment_scope(
        self,
        organization_id,  # type: str
        deployment_scope_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.DeploymentScopeDataResult", "_models.ErrorResult"]]
        """Gets a Deployment Scope.

        Gets a Deployment Scope.

        :param organization_id:
        :type organization_id: str
        :param deployment_scope_id:
        :type deployment_scope_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: DeploymentScopeDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.DeploymentScopeDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.DeploymentScopeDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_deployment_scope_request(
            organization_id=organization_id,
            deployment_scope_id=deployment_scope_id,
            template_url=self.get_deployment_scope.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('DeploymentScopeDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_deployment_scope.metadata = {'url': '/orgs/{organizationId}/scopes/{deploymentScopeId}'}  # type: ignore


    @distributed_trace
    def update_deployment_scope(
        self,
        organization_id,  # type: str
        deployment_scope_id,  # type: str
        body=None,  # type: Optional["_models.DeploymentScope"]
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.DeploymentScopeDataResult", "_models.ErrorResult"]]
        """Updates an existing Deployment Scope.

        Updates an existing Deployment Scope.

        :param organization_id:
        :type organization_id: str
        :param deployment_scope_id:
        :type deployment_scope_id: str
        :param body:
        :type body: ~teamcloud.models.DeploymentScope
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: DeploymentScopeDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.DeploymentScopeDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.DeploymentScopeDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        if body is not None:
            _json = self._serialize.body(body, 'DeploymentScope')
        else:
            _json = None

        request = build_update_deployment_scope_request(
            organization_id=organization_id,
            deployment_scope_id=deployment_scope_id,
            content_type=content_type,
            json=_json,
            template_url=self.update_deployment_scope.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('DeploymentScopeDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_deployment_scope.metadata = {'url': '/orgs/{organizationId}/scopes/{deploymentScopeId}'}  # type: ignore


    @distributed_trace
    def delete_deployment_scope(
        self,
        organization_id,  # type: str
        deployment_scope_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.DeploymentScopeDataResult", "_models.ErrorResult"]]
        """Deletes a Deployment Scope.

        Deletes a Deployment Scope.

        :param organization_id:
        :type organization_id: str
        :param deployment_scope_id:
        :type deployment_scope_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: DeploymentScopeDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.DeploymentScopeDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.DeploymentScopeDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_delete_deployment_scope_request(
            organization_id=organization_id,
            deployment_scope_id=deployment_scope_id,
            template_url=self.delete_deployment_scope.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 204:
            deserialized = self._deserialize('DeploymentScopeDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    delete_deployment_scope.metadata = {'url': '/orgs/{organizationId}/scopes/{deploymentScopeId}'}  # type: ignore


    @distributed_trace
    def initialize_authorization(
        self,
        organization_id,  # type: str
        deployment_scope_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.DeploymentScopeDataResult", "_models.ErrorResult"]]
        """Initialize a new authorization session for a deployment scope.

        Initialize a new authorization session for a deployment scope.

        :param organization_id:
        :type organization_id: str
        :param deployment_scope_id:
        :type deployment_scope_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: DeploymentScopeDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.DeploymentScopeDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.DeploymentScopeDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_initialize_authorization_request(
            organization_id=organization_id,
            deployment_scope_id=deployment_scope_id,
            template_url=self.initialize_authorization.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('DeploymentScopeDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    initialize_authorization.metadata = {'url': '/orgs/{organizationId}/scopes/{deploymentScopeId}/authorize/initialize'}  # type: ignore


    @distributed_trace
    def negotiate_signal_r(
        self,
        organization_id,  # type: str
        project_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> None
        """Negotiates the SignalR connection.

        Negotiates the SignalR connection.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: None, or the result of cls(response)
        :rtype: None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[None]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_negotiate_signal_r_request(
            organization_id=organization_id,
            project_id=project_id,
            template_url=self.negotiate_signal_r.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 401, 403]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        if cls:
            return cls(pipeline_response, None, {})

    negotiate_signal_r.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/negotiate'}  # type: ignore


    @distributed_trace
    def get_audit_entries(
        self,
        organization_id,  # type: str
        time_range=None,  # type: Optional[str]
        commands=None,  # type: Optional[List[str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.CommandAuditEntityListDataResult", "_models.ErrorResult"]]
        """Gets all audit entries.

        Gets all audit entries.

        :param organization_id:
        :type organization_id: str
        :param time_range:
        :type time_range: str
        :param commands:
        :type commands: list[str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: CommandAuditEntityListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.CommandAuditEntityListDataResult or ~teamcloud.models.ErrorResult or
         None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.CommandAuditEntityListDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_audit_entries_request(
            organization_id=organization_id,
            time_range=time_range,
            commands=commands,
            template_url=self.get_audit_entries.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('CommandAuditEntityListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_audit_entries.metadata = {'url': '/orgs/{organizationId}/audit'}  # type: ignore


    @distributed_trace
    def get_audit_entry(
        self,
        command_id,  # type: str
        organization_id,  # type: str
        expand=False,  # type: Optional[bool]
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.CommandAuditEntityDataResult", "_models.ErrorResult"]]
        """Gets an audit entry.

        Gets an audit entry.

        :param command_id:
        :type command_id: str
        :param organization_id:
        :type organization_id: str
        :param expand:
        :type expand: bool
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: CommandAuditEntityDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.CommandAuditEntityDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.CommandAuditEntityDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_audit_entry_request(
            command_id=command_id,
            organization_id=organization_id,
            expand=expand,
            template_url=self.get_audit_entry.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('CommandAuditEntityDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_audit_entry.metadata = {'url': '/orgs/{organizationId}/audit/{commandId}'}  # type: ignore


    @distributed_trace
    def get_audit_commands(
        self,
        organization_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.StringListDataResult", "_models.ErrorResult"]]
        """Gets all auditable commands.

        Gets all auditable commands.

        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StringListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StringListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.StringListDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_audit_commands_request(
            organization_id=organization_id,
            template_url=self.get_audit_commands.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('StringListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_audit_commands.metadata = {'url': '/orgs/{organizationId}/audit/commands'}  # type: ignore


    @distributed_trace
    def get_organizations(
        self,
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.OrganizationListDataResult", "_models.ErrorResult"]]
        """Gets all Organizations.

        Gets all Organizations.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: OrganizationListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.OrganizationListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.OrganizationListDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_organizations_request(
            template_url=self.get_organizations.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('OrganizationListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_organizations.metadata = {'url': '/orgs'}  # type: ignore


    @distributed_trace
    def create_organization(
        self,
        body=None,  # type: Optional["_models.OrganizationDefinition"]
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.OrganizationDataResult", "_models.ErrorResult"]]
        """Creates a new Organization.

        Creates a new Organization.

        :param body:
        :type body: ~teamcloud.models.OrganizationDefinition
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: OrganizationDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.OrganizationDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.OrganizationDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        if body is not None:
            _json = self._serialize.body(body, 'OrganizationDefinition')
        else:
            _json = None

        request = build_create_organization_request(
            content_type=content_type,
            json=_json,
            template_url=self.create_organization.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 401, 403, 404, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 201:
            deserialized = self._deserialize('OrganizationDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_organization.metadata = {'url': '/orgs'}  # type: ignore


    @distributed_trace
    def get_organization(
        self,
        organization_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.OrganizationDataResult", "_models.ErrorResult"]]
        """Gets an Organization.

        Gets an Organization.

        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: OrganizationDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.OrganizationDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.OrganizationDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_organization_request(
            organization_id=organization_id,
            template_url=self.get_organization.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('OrganizationDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_organization.metadata = {'url': '/orgs/{organizationId}'}  # type: ignore


    @distributed_trace
    def delete_organization(
        self,
        organization_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.StatusResult", "_models.ErrorResult"]]
        """Deletes an existing Organization.

        Deletes an existing Organization.

        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.StatusResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_delete_organization_request(
            organization_id=organization_id,
            template_url=self.delete_organization.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    delete_organization.metadata = {'url': '/orgs/{organizationId}'}  # type: ignore


    @distributed_trace
    def get_organization_users(
        self,
        organization_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.UserListDataResult", "_models.ErrorResult"]]
        """Gets all Users.

        Gets all Users.

        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UserListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.UserListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.UserListDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_organization_users_request(
            organization_id=organization_id,
            template_url=self.get_organization_users.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('UserListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_organization_users.metadata = {'url': '/orgs/{organizationId}/users'}  # type: ignore


    @distributed_trace
    def create_organization_user(
        self,
        organization_id,  # type: str
        body=None,  # type: Optional["_models.UserDefinition"]
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.UserDataResult", "_models.ErrorResult"]]
        """Creates a new User.

        Creates a new User.

        :param organization_id:
        :type organization_id: str
        :param body:
        :type body: ~teamcloud.models.UserDefinition
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UserDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.UserDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.UserDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        if body is not None:
            _json = self._serialize.body(body, 'UserDefinition')
        else:
            _json = None

        request = build_create_organization_user_request(
            organization_id=organization_id,
            content_type=content_type,
            json=_json,
            template_url=self.create_organization_user.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 401, 403, 404, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 201:
            deserialized = self._deserialize('UserDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_organization_user.metadata = {'url': '/orgs/{organizationId}/users'}  # type: ignore


    @distributed_trace
    def get_organization_user(
        self,
        user_id,  # type: str
        organization_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.UserDataResult", "_models.ErrorResult"]]
        """Gets a User.

        Gets a User.

        :param user_id:
        :type user_id: str
        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UserDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.UserDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.UserDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_organization_user_request(
            user_id=user_id,
            organization_id=organization_id,
            template_url=self.get_organization_user.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('UserDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_organization_user.metadata = {'url': '/orgs/{organizationId}/users/{userId}'}  # type: ignore


    @distributed_trace
    def update_organization_user(
        self,
        user_id,  # type: str
        organization_id,  # type: str
        body=None,  # type: Optional["_models.User"]
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.UserDataResult", "_models.StatusResult", "_models.ErrorResult"]]
        """Updates an existing User.

        Updates an existing User.

        :param user_id:
        :type user_id: str
        :param organization_id:
        :type organization_id: str
        :param body:
        :type body: ~teamcloud.models.User
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UserDataResult or StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.UserDataResult or ~teamcloud.models.StatusResult or
         ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.UserDataResult", "_models.StatusResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        if body is not None:
            _json = self._serialize.body(body, 'User')
        else:
            _json = None

        request = build_update_organization_user_request(
            user_id=user_id,
            organization_id=organization_id,
            content_type=content_type,
            json=_json,
            template_url=self.update_organization_user.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('UserDataResult', pipeline_response)

        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_organization_user.metadata = {'url': '/orgs/{organizationId}/users/{userId}'}  # type: ignore


    @distributed_trace
    def delete_organization_user(
        self,
        user_id,  # type: str
        organization_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.StatusResult", "_models.UserDataResult", "_models.ErrorResult"]]
        """Deletes an existing User.

        Deletes an existing User.

        :param user_id:
        :type user_id: str
        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or UserDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.UserDataResult or
         ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.StatusResult", "_models.UserDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_delete_organization_user_request(
            user_id=user_id,
            organization_id=organization_id,
            template_url=self.delete_organization_user.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 204, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 204:
            deserialized = self._deserialize('UserDataResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    delete_organization_user.metadata = {'url': '/orgs/{organizationId}/users/{userId}'}  # type: ignore


    @distributed_trace
    def get_organization_user_me(
        self,
        organization_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.UserDataResult", "_models.ErrorResult"]]
        """Gets a User A User matching the current authenticated user.

        Gets a User A User matching the current authenticated user.

        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UserDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.UserDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.UserDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_organization_user_me_request(
            organization_id=organization_id,
            template_url=self.get_organization_user_me.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('UserDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_organization_user_me.metadata = {'url': '/orgs/{organizationId}/me'}  # type: ignore


    @distributed_trace
    def update_organization_user_me(
        self,
        organization_id,  # type: str
        body=None,  # type: Optional["_models.User"]
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.UserDataResult", "_models.StatusResult", "_models.ErrorResult"]]
        """Updates an existing User.

        Updates an existing User.

        :param organization_id:
        :type organization_id: str
        :param body:
        :type body: ~teamcloud.models.User
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UserDataResult or StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.UserDataResult or ~teamcloud.models.StatusResult or
         ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.UserDataResult", "_models.StatusResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        if body is not None:
            _json = self._serialize.body(body, 'User')
        else:
            _json = None

        request = build_update_organization_user_me_request(
            organization_id=organization_id,
            content_type=content_type,
            json=_json,
            template_url=self.update_organization_user_me.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('UserDataResult', pipeline_response)

        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_organization_user_me.metadata = {'url': '/orgs/{organizationId}/me'}  # type: ignore


    @distributed_trace
    def get_projects(
        self,
        organization_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.ProjectListDataResult", "_models.ErrorResult"]]
        """Gets all Projects.

        Gets all Projects.

        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ProjectListDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_projects_request(
            organization_id=organization_id,
            template_url=self.get_projects.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProjectListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_projects.metadata = {'url': '/orgs/{organizationId}/projects'}  # type: ignore


    @distributed_trace
    def create_project(
        self,
        organization_id,  # type: str
        body=None,  # type: Optional["_models.ProjectDefinition"]
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.ProjectDataResult", "_models.StatusResult", "_models.ErrorResult"]]
        """Creates a new Project.

        Creates a new Project.

        :param organization_id:
        :type organization_id: str
        :param body:
        :type body: ~teamcloud.models.ProjectDefinition
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectDataResult or StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectDataResult or ~teamcloud.models.StatusResult or
         ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ProjectDataResult", "_models.StatusResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        if body is not None:
            _json = self._serialize.body(body, 'ProjectDefinition')
        else:
            _json = None

        request = build_create_project_request(
            organization_id=organization_id,
            content_type=content_type,
            json=_json,
            template_url=self.create_project.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201, 202, 400, 401, 403, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 201:
            deserialized = self._deserialize('ProjectDataResult', pipeline_response)

        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_project.metadata = {'url': '/orgs/{organizationId}/projects'}  # type: ignore


    @distributed_trace
    def get_project(
        self,
        project_id,  # type: str
        organization_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.ProjectDataResult", "_models.ErrorResult"]]
        """Gets a Project.

        Gets a Project.

        :param project_id:
        :type project_id: str
        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ProjectDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_project_request(
            project_id=project_id,
            organization_id=organization_id,
            template_url=self.get_project.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProjectDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_project.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}'}  # type: ignore


    @distributed_trace
    def delete_project(
        self,
        project_id,  # type: str
        organization_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.StatusResult", "_models.ErrorResult"]]
        """Deletes a Project.

        Deletes a Project.

        :param project_id:
        :type project_id: str
        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.StatusResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_delete_project_request(
            project_id=project_id,
            organization_id=organization_id,
            template_url=self.delete_project.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    delete_project.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}'}  # type: ignore


    @distributed_trace
    def get_project_identities(
        self,
        organization_id,  # type: str
        project_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.ProjectIdentityListDataResult", "_models.ErrorResult"]]
        """Gets all Project Identities.

        Gets all Project Identities.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectIdentityListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectIdentityListDataResult or ~teamcloud.models.ErrorResult or
         None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ProjectIdentityListDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_project_identities_request(
            organization_id=organization_id,
            project_id=project_id,
            template_url=self.get_project_identities.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProjectIdentityListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_project_identities.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/identities'}  # type: ignore


    @distributed_trace
    def create_project_identity(
        self,
        organization_id,  # type: str
        project_id,  # type: str
        body=None,  # type: Optional["_models.ProjectIdentityDefinition"]
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.ProjectIdentityDataResult", "_models.ErrorResult"]]
        """Creates a new Project Identity.

        Creates a new Project Identity.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param body:
        :type body: ~teamcloud.models.ProjectIdentityDefinition
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectIdentityDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectIdentityDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ProjectIdentityDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        if body is not None:
            _json = self._serialize.body(body, 'ProjectIdentityDefinition')
        else:
            _json = None

        request = build_create_project_identity_request(
            organization_id=organization_id,
            project_id=project_id,
            content_type=content_type,
            json=_json,
            template_url=self.create_project_identity.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 401, 403, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 201:
            deserialized = self._deserialize('ProjectIdentityDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_project_identity.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/identities'}  # type: ignore


    @distributed_trace
    def get_project_identity(
        self,
        project_identity_id,  # type: str
        organization_id,  # type: str
        project_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.ProjectIdentityDataResult", "_models.ErrorResult"]]
        """Gets a Project Identity.

        Gets a Project Identity.

        :param project_identity_id:
        :type project_identity_id: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectIdentityDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectIdentityDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ProjectIdentityDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_project_identity_request(
            project_identity_id=project_identity_id,
            organization_id=organization_id,
            project_id=project_id,
            template_url=self.get_project_identity.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProjectIdentityDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_project_identity.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/identities/{projectIdentityId}'}  # type: ignore


    @distributed_trace
    def update_project_identity(
        self,
        project_identity_id,  # type: str
        organization_id,  # type: str
        project_id,  # type: str
        body=None,  # type: Optional["_models.ProjectIdentity"]
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.StatusResult", "_models.ErrorResult"]]
        """Updates an existing Project Identity.

        Updates an existing Project Identity.

        :param project_identity_id:
        :type project_identity_id: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param body:
        :type body: ~teamcloud.models.ProjectIdentity
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.StatusResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        if body is not None:
            _json = self._serialize.body(body, 'ProjectIdentity')
        else:
            _json = None

        request = build_update_project_identity_request(
            project_identity_id=project_identity_id,
            organization_id=organization_id,
            project_id=project_id,
            content_type=content_type,
            json=_json,
            template_url=self.update_project_identity.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_project_identity.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/identities/{projectIdentityId}'}  # type: ignore


    @distributed_trace
    def delete_project_identity(
        self,
        project_identity_id,  # type: str
        organization_id,  # type: str
        project_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.ProjectIdentityDataResult", "_models.ErrorResult"]]
        """Deletes a Project Identity.

        Deletes a Project Identity.

        :param project_identity_id:
        :type project_identity_id: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectIdentityDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectIdentityDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ProjectIdentityDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_delete_project_identity_request(
            project_identity_id=project_identity_id,
            organization_id=organization_id,
            project_id=project_id,
            template_url=self.delete_project_identity.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 204:
            deserialized = self._deserialize('ProjectIdentityDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    delete_project_identity.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/identities/{projectIdentityId}'}  # type: ignore


    @distributed_trace
    def get_project_tags(
        self,
        organization_id,  # type: str
        project_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.StringDictionaryDataResult", "_models.ErrorResult"]]
        """Gets all Tags for a Project.

        Gets all Tags for a Project.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StringDictionaryDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StringDictionaryDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.StringDictionaryDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_project_tags_request(
            organization_id=organization_id,
            project_id=project_id,
            template_url=self.get_project_tags.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('StringDictionaryDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_project_tags.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/tags'}  # type: ignore


    @distributed_trace
    def create_project_tag(
        self,
        organization_id,  # type: str
        project_id,  # type: str
        body=None,  # type: Optional[Dict[str, str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.StatusResult", "_models.ErrorResult"]]
        """Creates a new Project Tag.

        Creates a new Project Tag.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param body:
        :type body: dict[str, str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.StatusResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        if body is not None:
            _json = self._serialize.body(body, '{str}')
        else:
            _json = None

        request = build_create_project_tag_request(
            organization_id=organization_id,
            project_id=project_id,
            content_type=content_type,
            json=_json,
            template_url=self.create_project_tag.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 401, 403, 404, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_project_tag.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/tags'}  # type: ignore


    @distributed_trace
    def update_project_tag(
        self,
        organization_id,  # type: str
        project_id,  # type: str
        body=None,  # type: Optional[Dict[str, str]]
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.StatusResult", "_models.ErrorResult"]]
        """Updates an existing Project Tag.

        Updates an existing Project Tag.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param body:
        :type body: dict[str, str]
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.StatusResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        if body is not None:
            _json = self._serialize.body(body, '{str}')
        else:
            _json = None

        request = build_update_project_tag_request(
            organization_id=organization_id,
            project_id=project_id,
            content_type=content_type,
            json=_json,
            template_url=self.update_project_tag.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_project_tag.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/tags'}  # type: ignore


    @distributed_trace
    def get_project_tag_by_key(
        self,
        tag_key,  # type: str
        organization_id,  # type: str
        project_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.StringDictionaryDataResult", "_models.ErrorResult"]]
        """Gets a Project Tag by Key.

        Gets a Project Tag by Key.

        :param tag_key:
        :type tag_key: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StringDictionaryDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StringDictionaryDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.StringDictionaryDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_project_tag_by_key_request(
            tag_key=tag_key,
            organization_id=organization_id,
            project_id=project_id,
            template_url=self.get_project_tag_by_key.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('StringDictionaryDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_project_tag_by_key.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/tags/{tagKey}'}  # type: ignore


    @distributed_trace
    def delete_project_tag(
        self,
        tag_key,  # type: str
        organization_id,  # type: str
        project_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.StatusResult", "_models.ErrorResult"]]
        """Deletes an existing Project Tag.

        Deletes an existing Project Tag.

        :param tag_key:
        :type tag_key: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.StatusResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_delete_project_tag_request(
            tag_key=tag_key,
            organization_id=organization_id,
            project_id=project_id,
            template_url=self.delete_project_tag.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    delete_project_tag.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/tags/{tagKey}'}  # type: ignore


    @distributed_trace
    def get_project_templates(
        self,
        organization_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.ProjectTemplateListDataResult", "_models.ErrorResult"]]
        """Gets all Project Templates.

        Gets all Project Templates.

        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectTemplateListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectTemplateListDataResult or ~teamcloud.models.ErrorResult or
         None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ProjectTemplateListDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_project_templates_request(
            organization_id=organization_id,
            template_url=self.get_project_templates.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProjectTemplateListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_project_templates.metadata = {'url': '/orgs/{organizationId}/templates'}  # type: ignore


    @distributed_trace
    def create_project_template(
        self,
        organization_id,  # type: str
        body=None,  # type: Optional["_models.ProjectTemplateDefinition"]
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.ProjectTemplateDataResult", "_models.ErrorResult"]]
        """Creates a new Project Template.

        Creates a new Project Template.

        :param organization_id:
        :type organization_id: str
        :param body:
        :type body: ~teamcloud.models.ProjectTemplateDefinition
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectTemplateDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectTemplateDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ProjectTemplateDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        if body is not None:
            _json = self._serialize.body(body, 'ProjectTemplateDefinition')
        else:
            _json = None

        request = build_create_project_template_request(
            organization_id=organization_id,
            content_type=content_type,
            json=_json,
            template_url=self.create_project_template.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 401, 403, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 201:
            deserialized = self._deserialize('ProjectTemplateDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_project_template.metadata = {'url': '/orgs/{organizationId}/templates'}  # type: ignore


    @distributed_trace
    def get_project_template(
        self,
        project_template_id,  # type: str
        organization_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.ProjectTemplateDataResult", "_models.ErrorResult"]]
        """Gets a Project Template.

        Gets a Project Template.

        :param project_template_id:
        :type project_template_id: str
        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectTemplateDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectTemplateDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ProjectTemplateDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_project_template_request(
            project_template_id=project_template_id,
            organization_id=organization_id,
            template_url=self.get_project_template.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProjectTemplateDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_project_template.metadata = {'url': '/orgs/{organizationId}/templates/{projectTemplateId}'}  # type: ignore


    @distributed_trace
    def update_project_template(
        self,
        project_template_id,  # type: str
        organization_id,  # type: str
        body=None,  # type: Optional["_models.ProjectTemplate"]
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.ProjectTemplateDataResult", "_models.ErrorResult"]]
        """Updates an existing Project Template.

        Updates an existing Project Template.

        :param project_template_id:
        :type project_template_id: str
        :param organization_id:
        :type organization_id: str
        :param body:
        :type body: ~teamcloud.models.ProjectTemplate
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectTemplateDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectTemplateDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ProjectTemplateDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        if body is not None:
            _json = self._serialize.body(body, 'ProjectTemplate')
        else:
            _json = None

        request = build_update_project_template_request(
            project_template_id=project_template_id,
            organization_id=organization_id,
            content_type=content_type,
            json=_json,
            template_url=self.update_project_template.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProjectTemplateDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_project_template.metadata = {'url': '/orgs/{organizationId}/templates/{projectTemplateId}'}  # type: ignore


    @distributed_trace
    def delete_project_template(
        self,
        project_template_id,  # type: str
        organization_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.ProjectTemplateDataResult", "_models.ErrorResult"]]
        """Deletes a Project Template.

        Deletes a Project Template.

        :param project_template_id:
        :type project_template_id: str
        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectTemplateDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectTemplateDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ProjectTemplateDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_delete_project_template_request(
            project_template_id=project_template_id,
            organization_id=organization_id,
            template_url=self.delete_project_template.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [204, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 204:
            deserialized = self._deserialize('ProjectTemplateDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    delete_project_template.metadata = {'url': '/orgs/{organizationId}/templates/{projectTemplateId}'}  # type: ignore


    @distributed_trace
    def get_project_users(
        self,
        organization_id,  # type: str
        project_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.UserListDataResult", "_models.ErrorResult"]]
        """Gets all Users for a Project.

        Gets all Users for a Project.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UserListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.UserListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.UserListDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_project_users_request(
            organization_id=organization_id,
            project_id=project_id,
            template_url=self.get_project_users.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('UserListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_project_users.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/users'}  # type: ignore


    @distributed_trace
    def create_project_user(
        self,
        organization_id,  # type: str
        project_id,  # type: str
        body=None,  # type: Optional["_models.UserDefinition"]
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.UserDataResult", "_models.StatusResult", "_models.ErrorResult"]]
        """Creates a new Project User.

        Creates a new Project User.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param body:
        :type body: ~teamcloud.models.UserDefinition
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UserDataResult or StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.UserDataResult or ~teamcloud.models.StatusResult or
         ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.UserDataResult", "_models.StatusResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        if body is not None:
            _json = self._serialize.body(body, 'UserDefinition')
        else:
            _json = None

        request = build_create_project_user_request(
            organization_id=organization_id,
            project_id=project_id,
            content_type=content_type,
            json=_json,
            template_url=self.create_project_user.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201, 202, 400, 401, 403, 404, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 201:
            deserialized = self._deserialize('UserDataResult', pipeline_response)

        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_project_user.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/users'}  # type: ignore


    @distributed_trace
    def get_project_user(
        self,
        user_id,  # type: str
        organization_id,  # type: str
        project_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.UserDataResult", "_models.ErrorResult"]]
        """Gets a Project User by ID or email address.

        Gets a Project User by ID or email address.

        :param user_id:
        :type user_id: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UserDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.UserDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.UserDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_project_user_request(
            user_id=user_id,
            organization_id=organization_id,
            project_id=project_id,
            template_url=self.get_project_user.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('UserDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_project_user.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/users/{userId}'}  # type: ignore


    @distributed_trace
    def update_project_user(
        self,
        user_id,  # type: str
        organization_id,  # type: str
        project_id,  # type: str
        body=None,  # type: Optional["_models.User"]
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.UserDataResult", "_models.StatusResult", "_models.ErrorResult"]]
        """Updates an existing Project User.

        Updates an existing Project User.

        :param user_id:
        :type user_id: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param body:
        :type body: ~teamcloud.models.User
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UserDataResult or StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.UserDataResult or ~teamcloud.models.StatusResult or
         ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.UserDataResult", "_models.StatusResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        if body is not None:
            _json = self._serialize.body(body, 'User')
        else:
            _json = None

        request = build_update_project_user_request(
            user_id=user_id,
            organization_id=organization_id,
            project_id=project_id,
            content_type=content_type,
            json=_json,
            template_url=self.update_project_user.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('UserDataResult', pipeline_response)

        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_project_user.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/users/{userId}'}  # type: ignore


    @distributed_trace
    def delete_project_user(
        self,
        user_id,  # type: str
        organization_id,  # type: str
        project_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.StatusResult", "_models.ErrorResult"]]
        """Deletes an existing Project User.

        Deletes an existing Project User.

        :param user_id:
        :type user_id: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.StatusResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_delete_project_user_request(
            user_id=user_id,
            organization_id=organization_id,
            project_id=project_id,
            template_url=self.delete_project_user.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    delete_project_user.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/users/{userId}'}  # type: ignore


    @distributed_trace
    def get_project_user_me(
        self,
        organization_id,  # type: str
        project_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.UserDataResult", "_models.ErrorResult"]]
        """Gets a Project User for the calling user.

        Gets a Project User for the calling user.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UserDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.UserDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.UserDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_project_user_me_request(
            organization_id=organization_id,
            project_id=project_id,
            template_url=self.get_project_user_me.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('UserDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_project_user_me.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/users/me'}  # type: ignore


    @distributed_trace
    def update_project_user_me(
        self,
        organization_id,  # type: str
        project_id,  # type: str
        body=None,  # type: Optional["_models.User"]
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.UserDataResult", "_models.StatusResult", "_models.ErrorResult"]]
        """Updates an existing Project User.

        Updates an existing Project User.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param body:
        :type body: ~teamcloud.models.User
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: UserDataResult or StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.UserDataResult or ~teamcloud.models.StatusResult or
         ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.UserDataResult", "_models.StatusResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        if body is not None:
            _json = self._serialize.body(body, 'User')
        else:
            _json = None

        request = build_update_project_user_me_request(
            organization_id=organization_id,
            project_id=project_id,
            content_type=content_type,
            json=_json,
            template_url=self.update_project_user_me.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('UserDataResult', pipeline_response)

        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_project_user_me.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/users/me'}  # type: ignore


    @distributed_trace
    def get_info(
        self,
        **kwargs  # type: Any
    ):
        # type: (...) -> "_models.TeamCloudInformationDataResult"
        """Gets information about this TeamCloud deployment.

        Gets information about this TeamCloud deployment.

        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: TeamCloudInformationDataResult, or the result of cls(response)
        :rtype: ~teamcloud.models.TeamCloudInformationDataResult
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType["_models.TeamCloudInformationDataResult"]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_info_request(
            template_url=self.get_info.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = self._deserialize('TeamCloudInformationDataResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_info.metadata = {'url': '/'}  # type: ignore


    @distributed_trace
    def get_schedules(
        self,
        organization_id,  # type: str
        project_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.ScheduleListDataResult", "_models.ErrorResult"]]
        """Gets all Schedule.

        Gets all Schedule.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ScheduleListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ScheduleListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ScheduleListDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_schedules_request(
            organization_id=organization_id,
            project_id=project_id,
            template_url=self.get_schedules.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ScheduleListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_schedules.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/schedules'}  # type: ignore


    @distributed_trace
    def create_schedule(
        self,
        organization_id,  # type: str
        project_id,  # type: str
        body=None,  # type: Optional["_models.ScheduleDefinition"]
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.ScheduleDataResult", "_models.ErrorResult"]]
        """Creates a new Project Schedule.

        Creates a new Project Schedule.

        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param body:
        :type body: ~teamcloud.models.ScheduleDefinition
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ScheduleDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ScheduleDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ScheduleDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        if body is not None:
            _json = self._serialize.body(body, 'ScheduleDefinition')
        else:
            _json = None

        request = build_create_schedule_request(
            organization_id=organization_id,
            project_id=project_id,
            content_type=content_type,
            json=_json,
            template_url=self.create_schedule.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [201, 400, 401, 403, 404, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 201:
            deserialized = self._deserialize('ScheduleDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    create_schedule.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/schedules'}  # type: ignore


    @distributed_trace
    def get_schedule(
        self,
        schedule_id,  # type: str
        organization_id,  # type: str
        project_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.ScheduleDataResult", "_models.ErrorResult"]]
        """Gets the Schedule.

        Gets the Schedule.

        :param schedule_id:
        :type schedule_id: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ScheduleDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ScheduleDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ScheduleDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_schedule_request(
            schedule_id=schedule_id,
            organization_id=organization_id,
            project_id=project_id,
            template_url=self.get_schedule.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ScheduleDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_schedule.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/schedules/{scheduleId}'}  # type: ignore


    @distributed_trace
    def update_schedule(
        self,
        schedule_id,  # type: str
        organization_id,  # type: str
        project_id,  # type: str
        body=None,  # type: Optional["_models.Schedule"]
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.ScheduleDataResult", "_models.ErrorResult"]]
        """Updates a Project Schedule.

        Updates a Project Schedule.

        :param schedule_id:
        :type schedule_id: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :param body:
        :type body: ~teamcloud.models.Schedule
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ScheduleDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ScheduleDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ScheduleDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        content_type = kwargs.pop('content_type', "application/json")  # type: Optional[str]

        if body is not None:
            _json = self._serialize.body(body, 'Schedule')
        else:
            _json = None

        request = build_update_schedule_request(
            schedule_id=schedule_id,
            organization_id=organization_id,
            project_id=project_id,
            content_type=content_type,
            json=_json,
            template_url=self.update_schedule.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404, 409]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ScheduleDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 409:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    update_schedule.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/schedules/{scheduleId}'}  # type: ignore


    @distributed_trace
    def run_schedule(
        self,
        schedule_id,  # type: str
        organization_id,  # type: str
        project_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.ScheduleDataResult", "_models.ErrorResult"]]
        """Runs a Project Schedule.

        Runs a Project Schedule.

        :param schedule_id:
        :type schedule_id: str
        :param organization_id:
        :type organization_id: str
        :param project_id:
        :type project_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ScheduleDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ScheduleDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ScheduleDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_run_schedule_request(
            schedule_id=schedule_id,
            organization_id=organization_id,
            project_id=project_id,
            template_url=self.run_schedule.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ScheduleDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    run_schedule.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/schedules/{scheduleId}/run'}  # type: ignore


    @distributed_trace
    def get_status(
        self,
        tracking_id,  # type: str
        organization_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.StatusResult", "_models.ErrorResult"]]
        """Gets the status of a long-running operation.

        Gets the status of a long-running operation.

        :param tracking_id:
        :type tracking_id: str
        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.StatusResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_status_request(
            tracking_id=tracking_id,
            organization_id=organization_id,
            template_url=self.get_status.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 302, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 302:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_status.metadata = {'url': '/orgs/{organizationId}/status/{trackingId}'}  # type: ignore


    @distributed_trace
    def get_project_status(
        self,
        project_id,  # type: str
        tracking_id,  # type: str
        organization_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.StatusResult", "_models.ErrorResult"]]
        """Gets the status of a long-running operation.

        Gets the status of a long-running operation.

        :param project_id:
        :type project_id: str
        :param tracking_id:
        :type tracking_id: str
        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: StatusResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.StatusResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.StatusResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_project_status_request(
            project_id=project_id,
            tracking_id=tracking_id,
            organization_id=organization_id,
            template_url=self.get_project_status.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 202, 302, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 202:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 302:
            deserialized = self._deserialize('StatusResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_project_status.metadata = {'url': '/orgs/{organizationId}/projects/{projectId}/status/{trackingId}'}  # type: ignore


    @distributed_trace
    def get_user_projects(
        self,
        organization_id,  # type: str
        user_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.ProjectListDataResult", "_models.ErrorResult"]]
        """Gets all Projects for a User.

        Gets all Projects for a User.

        :param organization_id:
        :type organization_id: str
        :param user_id:
        :type user_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ProjectListDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_user_projects_request(
            organization_id=organization_id,
            user_id=user_id,
            template_url=self.get_user_projects.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProjectListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_user_projects.metadata = {'url': '/orgs/{organizationId}/users/{userId}/projects'}  # type: ignore


    @distributed_trace
    def get_user_projects_me(
        self,
        organization_id,  # type: str
        **kwargs  # type: Any
    ):
        # type: (...) -> Optional[Union["_models.ProjectListDataResult", "_models.ErrorResult"]]
        """Gets all Projects for a User.

        Gets all Projects for a User.

        :param organization_id:
        :type organization_id: str
        :keyword callable cls: A custom type or function that will be passed the direct response
        :return: ProjectListDataResult or ErrorResult, or the result of cls(response)
        :rtype: ~teamcloud.models.ProjectListDataResult or ~teamcloud.models.ErrorResult or None
        :raises: ~azure.core.exceptions.HttpResponseError
        """
        cls = kwargs.pop('cls', None)  # type: ClsType[Optional[Union["_models.ProjectListDataResult", "_models.ErrorResult"]]]
        error_map = {
            401: ClientAuthenticationError, 404: ResourceNotFoundError, 409: ResourceExistsError
        }
        error_map.update(kwargs.pop('error_map', {}))

        
        request = build_get_user_projects_me_request(
            organization_id=organization_id,
            template_url=self.get_user_projects_me.metadata['url'],
        )
        request = _convert_request(request)
        request.url = self._client.format_url(request.url)

        pipeline_response = self._client._pipeline.run(request, stream=False, **kwargs)
        response = pipeline_response.http_response

        if response.status_code not in [200, 400, 401, 403, 404]:
            map_error(status_code=response.status_code, response=response, error_map=error_map)
            raise HttpResponseError(response=response)

        deserialized = None
        if response.status_code == 200:
            deserialized = self._deserialize('ProjectListDataResult', pipeline_response)

        if response.status_code == 400:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if response.status_code == 404:
            deserialized = self._deserialize('ErrorResult', pipeline_response)

        if cls:
            return cls(pipeline_response, deserialized, {})

        return deserialized

    get_user_projects_me.metadata = {'url': '/orgs/{organizationId}/me/projects'}  # type: ignore

